---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: 리플렉션 (1)

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java,The Java Manipulation]
# thumbnail image for post
img: ":java.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-09-08 23:55:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-09-08 23:55:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# 리플렉션 API 1부: 클래스 정보 조회

### 리플렉션은  스프링의 Depedency Injection은 어떻게 동작할까 ? 라는 의문점에 시작한다.

- BookService.java

```java
@Service
public class BookService{

	@Autowire
	BookRepository bookRepository;
}
```

### 의문점 1. bookRepository 인스턴스는 어떻게  null이 아닌걸까 ?

### 의문점 2. 스프링은 어떻게 BookService 인스턴스에 BookRepository 인스턴스를 넣어준 것일까 ?

두 가지 의문점을 리플렉션을 학습하고 의문점들을 해소해 나아가보자.!

---

## 리플렉션의 시작

리플렉션의 시작은 Class<T>로부터 시작된다.

[Class (Java Platform SE 8 )](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html)

공식 문서에서는 Class를 이렇게 정의하고 있다.

```java
public final classClass<T>
extends Object
implements Serializable,GenericDeclaration,Type,AnnotatedElement
```

- Class 클래스의 인스턴스는 실행 중인 Java 애플리케이션의 클래스와 인터페이스를 나타낸다.
- 열거형은 일종의 클래스이고 주석은 일종의 인터페이스이다.
- 모든 배열은 또한 동일한 요소 유형 및 차원 수를 가진 모든 배열에서 공유하는 Class 객체로 반영되는 클래스에 속한다.
- 기본 Java 유형(boolean, byte, char, short, int, long, float 및 double)과 void 키워드도 Class 객체로 표현된다.
- 클래스에 공개 생성자가 없습니다.
- 대신 Class 객체는 클래스가 로드될 때 Java Virtual Machine에 의해 자동으로 생성되고 클래스 로더에서 defineClass 메소드를 호출하여 생성됩니다.

다음 예제에서는 Class 객체를 사용하여 객체의 클래스 이름을 인쇄합니다.

```java
void printClassName(Object obj) {
         System.out.println("The class of " + obj +
                            " is " + obj.getClass().getName());
     }
```

클래스 리터럴을 사용하여 명명된 유형(또는 void의 경우)에 대한 Class 객체를 가져올 수도 있습니다.

예를 들어

```java
System.out.println("The name of class Foo is: "+Foo.class.getName());
```

위의 내용은 공식 문서에 대한 내용을 번역해서 작성한 것이다.  참고로 보면 좋다.

---

### Class<T>에 접근하는 방법

- 모든 클래스를 로딩 한 다음 Class<T>의 인스턴스가 생긴다. `“타입.class”`로 접근할 수 있다.

  ![Untitled](https://user-images.githubusercontent.com/56623911/189153708-22797924-fa4f-4070-a2e5-398a1148e463.png)



- 모든 인스턴스는 getClass() 메서드를 가지고 있다. `“인스턴스.getClass()` 로 접근할 수 있다.
- 클래스를 문자열로 읽어오는 방법
  - Class.forName(”FQCN”)
  - 클래스패스에 해당 클래스가 없다면 ClassNotFoundException이 발생한다.

### Class<T>를 통해 할 수 있는 것?

- 필드 (목록) 가져오기
- 메소드 (목록) 가져오기
- 상위 클래스 가져오기
- 인터페이스 (목록) 가져오기
- 애노테이션 가져오기
- 생성자 가져오기
- …등등

static 한 것은 언제 초기화 될까 ?



***참고***

- ***백기선님의 The Java code Manipulation 강의 중.***

<!-- outline-end -->
