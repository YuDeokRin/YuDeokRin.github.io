---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: 회원가입에 BCrypt 암호화 알고리즘 적용

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Database, DB]
# thumbnail image for post
img: ":SignUp.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-08-12 23:35:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-08-12 23:35:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# 회원가입에 BCrypt 암호화 알고리즘 적용 및 권한 설정 넣어주기

`비크립트`로 회원가입하고 비밀번호 암호화 하기

암호화 하는 이유 : 클라이언트가 준 데이터들을 받고 데이터베이스에 넣을 때 비밀번호가 암호화가 안된다. 암호화를 이용해서 데이터베이스에 있는 암호를 가려보자.

## **BCrypt** 암호화

비크립트란?

```java
├─📁COME.COS.photogram
   │
   └─📁config
       │
       └─ 📦 SecurityConfig.java

```

- 기존의 코드

```java
@EnableWebSecurity // 2.해당 파일로 시큐리티를 활성화 시켜준다.
@Configuration // 1. IoC에 등록해주는 것
public class SecurityConfig extends WebSecurityConfigurerAdapter {


    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
        http.authorizeRequests().antMatchers("/", "/user/**", "/image/**", "subscribe/**", "/comment/**").authenticated()
                .anyRequest().permitAll()
                .and()
                .formLogin()
                .loginPage("/auth/signin")
                .defaultSuccessUrl("/");
    }
}
```

- IoC에 BcryptPasswordEncoder 등록

```java
    @Bean
		public BcryptPasswordEncoder enocode() {
			return new BcryptPasswordEncoder();
		}

```

application이 실행되면서 SecurityConfig 가 IoC에 등록될 때 @Bean을 읽어서 `return new BcryptPasswordEncoder();` 해서 IoC에 BcryptPasswordEncoder 등록을 한다.

- Service에서 사용
  - `private final BcryptPasswordEncoder bcryptPasswordEncoder;` 추가
  - `String rawPassword = user.getPassword();` 추가
  - `String encPassword = bcryptPasswordEncoder.encode(rawPassword);` 추가


**encPassword는 암호회된 Password를 갖고있다. (해시로 되어있다. )**

```java
@RequiredArgsConstructor
@Service
public class AuthService {
    private final UserRepository userRepository;
		private final BcryptPasswordEncoder bcryptPasswordEncoder;

		@Transactional
    public User 회원가입(User user){
				String rawPassword = user.getPassword();
			  String encPassword = bcryptPasswordEncoder.encode(rawPassword);
        User userEntity =userRepository.save(user);
        return userEntity;
    }
}
```

- Password 암호화

```java
@RequiredArgsConstructor
@Service
public class AuthService {

    private final UserRepository userRepository;
		private final BcryptPasswordEncoder bcryptPasswordEncoder;

		@Transactional
    public User 회원가입(User user){
				String rawPassword = user.getPassword();
			  String encPassword = bcryptPasswordEncoder.encode(rawPassword);

				user.setPassword(encPassword); **// 패스워드 암호화 됨**

        User userEntity =userRepository.save(user);
        return userEntity;
    }
}
```

- 권한 넣어주기

`user.setRole("ROLE_USER);`

```java
@RequiredArgsConstructor
@Service
public class AuthService {

    private final UserRepository userRepository;
		private final BcryptPasswordEncoder bcryptPasswordEncoder;

		@Transactional
    public User 회원가입(User user){
				String rawPassword = user.getPassword();
			  String encPassword = bcryptPasswordEncoder.encode(rawPassword);

				user.setPassword(encPassword); **// 패스워드 암호화 됨**
				user.setRole("ROLE_USER); //관리자 ROLE_ADMIN
        User userEntity =userRepository.save(user);
        return userEntity;
    }
}
```

- username 이 중복된다.. 중복된 것을 못만들게하기

어떻게 중복을 없앨까 ?

```java
@Builder
@AllArgsConstructor // lombok embedded
@NoArgsConstructor // lombok embedded
@Data // lombok embedded
@Entity
public class User {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) //번호 증가 전략이 데이터베이스를 따라간다.
    private int id;

    private String username;
    private String password;

    private String name;
    private String website;
    private String bio;
    private String email;
    private String phone;
    private String gender;

    private String profileimageUrl;
    private String role;

    private LocalDateTime createDate;

    @PrePersist
    public void createDate(){
        this.createDate = LocalDateTime.now();
    }

}
```

**@Column(unique = true) 를 사용하여 username이 중복되는 것은 안되게 unique 제약 조건을 걸어준다.**

```java
@Builder
@AllArgsConstructor // lombok embedded
@NoArgsConstructor // lombok embedded
@Data // lombok embedded
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) //번호 증가 전략이 데이터베이스를 따라간다.
    private int id;

		@Column(unique = true)
    private String username;
    private String password;

    private String name;
    private String website;
    private String bio;
    private String email;
    private String phone;
    private String gender;

    private String profileimageUrl;
    private String role;

    private LocalDateTime createDate;

    @PrePersist
    public void createDate(){
        this.createDate = LocalDateTime.now();
    }

}
```

이번 글에서 비크립트를 사용하여 비밀번호를 암호화 해주고 권한 설정까지 넣어주었다.

여기서 생각나는 것은 제약조건을 enum로 만들어될까? 라는 고민을 했다. 1차 리팩토링 할 때 이 글을 다시보면서 enum으로 구현을 가능한지  알아봐야겠다.

### 정리

- **BCrypt 암호화 알고리즘**
- **권한 넣어주기**
- **@Column(unique = true)  중복 생성 불가하게 만들기**

<!-- outline-end -->
