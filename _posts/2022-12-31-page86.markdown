---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: Effective-Java(Item13)

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible
tags: [Effective_Java, Java]
# thumbnail image for post
img: ":Eff3.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-12-31 17:55:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-12-31 17:55:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->

# item 13. clone 재정의는 주의해서 진행하라.

## clone() 메소드는 무엇일까?

[Java clone 메소드 간략히 알아보자.](https://yudeokrin.github.io/posts/2022-12-30-page85)

글이 긴 것은 가독성이 좋지 않기 때문에 `clone`을 정리해서 블로그에 정리해놨다.

---

[얕은 복사와 깊은 복사](https://yudeokrin.github.io/posts/2022-12-29-page84)

clone() 메소드를 배우기에 앞서 얕은 복사와 깊은 복사의 개념을 숙지하면 좋을 것 같아서 정리해봤다.

---

## Cloneable 인터페이스의 역할

- cloneable은 클래스을 복제를 할 수 있는지 확인하기위한 용도로 쓰인다. → 이런 인터페이스를  `minxin interface` 라고 부른다.

<aside>
💡 **mixin (믹스인)이란?**
클래스가 본인의 기능 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다.

</aside>

## clone의 규약

### 1. x.clone() ≠ x

→ 반드시 true

### 2. x.clone().getClass() == x.getClass()

→ 반드시 true

### 3. x.clone().equals(x)

→ true일 수도 있고 아닐 수도 있다.

### 4. x.clone.getClass() == x.getClass()

관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.

---

## 가변상태를 참조하지 않는 clone 정의

- 가변 상태를 참조하지 않는 클래스용 clone 메서드

```java
@Override
public PhoneNumber clone() {
    try {
        return (PhoneNumber) super.clone();
    } catch (CloneNotSupportedException e) {
        throw new AssertionError(); // 일어날 수 없는 일.
    }
}
```

- 원래 clone의 모습

```java
@Override
protected Object clone() throws CloneSupportedException {
    return super.clone();
}
```

어떤 클래스(Object)를 상속받아서 Overriding을 할 때, 접근 지시자는 상위 클래스에 있는 접근지시자와 같거나 더 넓은 범위의 접근 지시자를 가져야한다.

<aside>
💡 **공변 반환 타이핑(convariant return typing)

메서드를 Overriding(재정의)할 때 재정의 된 메서드의 반환 타입이 상위 클래스의 메서드가 반환하는 하위 유형이 될 수 있다 라는 것**

</aside>

- 공변 반환 타이핑 예제

![Untitled](https://user-images.githubusercontent.com/56623911/210131061-c6b17294-908b-4064-8df4-9dce280c9253.png)


### 공변 반환 타이핑의 장점

- clone()이라는 메소드를 호출하는 부분에서 `타입 캐스팅`을 하지 않아도된다.

<!-- outline-end -->
