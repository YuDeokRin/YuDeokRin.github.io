---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: The Java8(자바에서 제공하는 함수형 인터페이스)

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java, Java 8]
# thumbnail image for post
img: ":java8.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-07-14 18:24:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-07-14 18:24:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# 자바에서 제공하는 함수형 인터페이스

## Java가 기본으로 제공하는 함수형 인터페이스

- [java.lang.function 패키지](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)
- 자바에서 미리 정의해둔 자주 사용할만한 함수인터페이스
  - Function<T, R>
  - BiFunction<T, U, R>
  - Consumer<T>
  - Supplier<T>
  - Predicate<T>
  - UnaryOperator<T>
  - BinaryOperator<T>

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| java.lang.Runnable | void run( ) | 매개변수도 없고, 반환값도 없음. |
| Supplier<T> | T get( )     T→ | 매개변수는 없고, 반환값만 있음. |
| Consumer<T> | T→    void accept(T t) | Supplier와 반대로 매개변수만 있고, 반환값이 없음 |
| Function<T, R> | T→   R apply(T t)    R→ | 일반적인 함수. 하나의 매개변수를 받아서 결과를 반환 |
| Predicate<T> | T→ boolean test(T t)   boolean→ | 조건식을 표현하는데 사용됨. 매개변수는 하나, 반환 타입은 boolean |

### ***Tip***

- 타입 문자는 ‘T’는 ‘Type’을, ‘R’은 ‘Return type’을 의미한다.

### Function<T, R>

- T 타입을 받아서 R 타입을 리턴하는 함수 인터페이스
  - R apply(T t)
- 함수 조합용 메소드
  - compose
  - andThen

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| Function<T, R> | T→   R apply(T t)    R→ | 일반적인 함수. 하나의 매개변수를 받아서 결과를 반환 |

- Function<T, R> → apply() 사용 : 인터페이스 재정의해서 표현

```java

//입력값type: Integer, 반환값 : Integer
public class A implements Function<Integer, Integer> {
    @Override
    public Integer apply(Integer integer) {
        return integer + 10;
    }
}
```

```java
public class Provided_Function {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.apply(1)); // return : 11
    }
}
```

이 예시는 인터페이스를 재정의(@Override)를 해서 표현한 방법

- Funtion<T, R> →  apply() 사용  : 람다식으로 표현

```java
public class Main{
		public static void main(String[] args){
			Function<Integer, Integer> plus10 = (number) -> i + 10;
			System.out.println(plus10.apply(1)); // return 11

		}
}
```

이 방법은 바로 람다식으로 표현하는 방법  → 람다식 표현방법을 안다면 코드가 훨씬 짧고 간결해진다.

함수 조합용 메소드

- 예제) compose()

```java
public class Main{
  public static void main(String[] args){
	Function<Integer, Integer> plus10 = (number) -> i + 10;
	Function<Integer, Integer> multiply2 = (i) -> i * 2;

	Function<Integer, Integer> multiply2AndPlus10 = plus10.compose(multiplu2);
	System.out.println(multiply2AndPlus10.apply(2)); //출력 : 14
  }
}
```

compose() 입력값을 갖고 먼저 multiply2라는 함수를 먼저  적용한다.  그리고 결과 값을 다시 plus10에 넘겨준다.

<img width="450" alt="스크린샷_2022-07-14_오후_5 23 30" src="https://user-images.githubusercontent.com/56623911/178945450-72c53731-0604-4ab1-836e-f16361f7226c.png">

<img width="250" alt="스크린샷_2022-07-14_오후_5 22 55" src="https://user-images.githubusercontent.com/56623911/178945465-5809802d-3df0-4b80-9e4b-31964127f8c9.png">

- 예제) andThen

```java
public class Main{
		public static void main(String[] args){
			Function<Integer, Integer> plus10 = (number) -> i + 10;
			Function<Integer, Integer> multiply2 = (i) -> i * 2;

			System.out.println(plus10.andThen(multiply2).apply(2));
		}
}
```
<img width="450" alt="스크린샷_2022-07-14_오후_5 25 47" src="https://user-images.githubusercontent.com/56623911/178945510-1da1a4a1-44cc-4530-980a-0cefa30fcf45.png">

<img width="250" alt="스크린샷_2022-07-14_오후_5 26 07" src="https://user-images.githubusercontent.com/56623911/178945518-e9a42d4b-86a6-4538-8426-6da2539fbc69.png">


### BiFunction<T, U, R>

- 두 개의 값(T,U)를 받아서 R타입을 리턴하는 함수 인터페이스
  - R apply(T t, U u)

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| BiFunction<T, U, R>  | T, U →       R apply(T t, U u)        R → | 두 개의 매개변수를 받아서 하나의 결과를 반환 |

### Consumer<T>

- T 타입을 받아서 아무값도 리턴하지 않는 함수 인터페이스
  - void Accept(T t)
- 함수 조합용 메소드
  - andThen

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| Consumer<T> | T→    void accept(T t) | Supplier와 반대로 매개변수만 있고, 반환값이 없음 |
- 예제) 람다식 표현

```java
public class Main{
		public static void main(String[] args){

			Consumer<Integer> printT = (i) -> System.out.println(i);
			printT.accept(10); // 출력 : 10

		}
}
```

- 예제) 메소드레퍼런스 표현

```java
public class Main{
 public static void main(String[] args){

  Consumer<Integer> printT = System.out::println; // 메소드 레퍼런스로 표현
  printT.accept(10); // 출력 : 10

 }
}
```

### Supplier<T>

- T 타입의 값을 제공하는 함수 인터페이스
  - T get()

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| Supplier<T> | T get( )     T→ | 매개변수는 없고, 반환값만 있음. |
- 예제

```java
public class Main{
		public static void main(String[] args){

			Supplier<Integer> get10 = () -> 10; // 인자가 없음 .  return만..
			System.out.println(get10.get()); // 10
		}
}
```

### Predicate<T>

- T타입을 받아서 boolean을 리턴하는 함수 인터페이스
  - boolean test(T t)
- 함수 조합용 메소드
  - And
  - Or
  - Negate

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| Predicate<T> | T ——> boolean test(T t)   boolean ——> | 조건식을 표현하는데 사용됨. 매개변수는 하나, 반환 타입은 boolean |

- 예제) Predicate<T>

```java
public class Main{
	public static void main(String[] args){

		//1. String 타입 받을 때
		// 처음 "Dante"라는 단어가 들어가는 데이터가 있는지 확인
		Predicate<String> startsWithDante = (s) - > s.startsWith("Dante");

		//2. Integer 타입 받을 때
		// 짝수가 맞는지 확인
		Predicate<Integer> isEven = (i) -> i%2 == 0;

	}
}
```

### UnaryOperator<T>

- Function<T, R>의 특수한 형태로, 입력값 하나를 받아서 동일한 타입을 리턴하는 함수 인터페이스

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| UnaryOperator<T> | T ——>  T apply(T t)      T ——> | Function의 자손, Function과 달리 매개 변수와 결과의 타입이 같다. |

```java
public class Main{
		public static void main(String[] args){

			//Function<Integer, Integer> plus10 = (number) -> i + 10;

			UnaryOperator<Integer> plus10 = (number) -> i + 10;

		}
}
```

Funtion<T, R> 받는 타입과 반환 타입이 다르면 function을 쓰는게 맞다.

하지만 받는 타입과 반환타입이 같으면 UnaryOperator를 쓰는 것이 더 깔끔하다.

### BinaryOperator<T>

- BiFunction<T, U, R>의 특수한 형태로, 동일한 타입의 입력값 두 개를 받아 리턴하는 함수 인터페이스

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| BinaryOperator<T> | T, T →   T apply(T t, T t)     → T  | BiFunction의 자손, BiFunction과 달리 매개변수와 결과의 타입이 같다. |

- 예제) BinaryOperator

```java
public class Main{
		public static void main(String[] args){

			BinaryOperator<Integer> doublePlus = (n1, n2) -> n1 + n2;
			Integer sum = doublePlus.apply(1,1);
			System.out.println(sum); // return : 2
		}
}
```

### 매개변수가 두 개인 함수형 인터페이스

매개변수가 2개인 함수형 인터페이스는 접두사 ‘Bi’가 붙는다.

| 함수형 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| BiConsumer<T, U> | T, U → void accept(T t, U u) | 두 개의 매개변수만 있고, 반환값이 없음 |
| BiPredicate<T, U> | T, U → boolean test(T t, U u)    boolean → | 조건식을 표현하는데 사용됨.
매개변수는 둘, 반환값은 boolean |
| BiFunction<T, U, R>  | T, U → R apply(T t, U u)     R → | 두 개의 매개변수를 받아서 하나의 결과를 반환 |

**Tip.**
Supplier는 매개변수는 없고 반환값만 존재하는데, 메서드는 두 개의 값을 반환할 수 없으므로 BiSupplier가 없는 것이다.

### UnaryOperator와 BinaryOperator

Function의 또 다른 변형으로 UnaryOperator와 BinaryOperator가 있다.

매개변수의 타입과 반환타입의 타입이 모두 일치한다는 점만 제외하고는 Function과 같다.

| 함수형 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| UnaryOperator<T> | T →         T apply(T t)           T→ | Function의 자손, Function과 달리 매개변수와 결과의 타입이 같다. |
| BinaryOperator<T> | T, T → T apply(T t, T t)        T →         | BiFunction의 자손, BiFunction과 달리 매개변수와 결과의 타입이 같다. |

**Tip.**

UnaryOperator와 BinaryOperator의 조상은 각각 Function과 BiFunction이다.



### 참고 : [백기선 - The Java8 ](https://www.inflearn.com/course/the-java-java8/dashboard)


<!-- outline-end -->
