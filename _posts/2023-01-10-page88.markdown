---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: Java Thread에 관하여

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java]
# thumbnail image for post
img: ":java.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2023-01-10 18:20:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2023-01-10 18:20:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->

# Thread

자바 프로그램을 실행 후 적어도 하나의 JVM이 시작된다.

보통 JVM이 시작되면 자바 프로세스(Process)가 시작한다.  프로세스 안에서 여러 개의 쓰레드가 존재하고 있다.

![Untitled](%E1%84%8A%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%85%E1%85%A1%E1%84%86%E1%85%A7%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%20%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%A1%E1%84%8B%E1%85%AD%20a014f0aaf0be46969497604a40fb2c06/Untitled.png)

우리가 Java 클래스를 실행하는 순간 자바 프로세스가 시작되고, main()  메소드가 수행되면서 하나의 쓰레드가 시작되는 것이다.

만약 많은 쓰레드가 필요하다면,  main() 메소드에서 쓰레드를 생성해 주면 된다. 자바를 사용하여 웹을 제공할 때에는 Tomcat과 같은 WAS(Web Application Server)를 사용한다. 이 WAS도 똑같이 main() 메소드에서 생성한 쓰레드들이 수행되는 것이다.

- 쓰레드라는 것을 왜 만들었을까?

프로세스가 하나 시작하려면 많은 자원(resource)이 필요하다.

만약 하나의 작업을 동시에 수행하려고 할 때 여러 개의 프로세스를 띄워서 실행하면 각각 메모리를 할당하여 주어야만 한다.

JVM은 기본적으로 아무런 옵션 없이 실행하면 OS마다 다르지만, 적어도 `32MB ~ 64MB(Mega byte)` 의 물리 메모리를 점유한다.

반면에 쓰레드를 하나 추가하면 1MB 이내의 메모리를 점유한다.  따라서, 쓰레드를 `“경량 프로세스(lightweight process)”` 라고 부른다.

- Tip. Thread 번역

  Thread라는 단어의 사전적인 의미는 실타래를 의미한다고한다.


---

## Runnable 인터페이스와 Thread 클래스

쓰레드 생성하는 방법

1. Runnable 인터페이스를 사용하는 법
2. Thread 클래스를 사용하는 방법

Runnable 인터페이스와 Thread 클래스는 모두 `java.lang` 패키지에 있다.

Runnable 인터페이스에 선언되어 있는 메소드

| 리턴 타입 | 메소드 이름 및 매개 변수  | 설명 |
| --- | --- | --- |
| void | run() | 쓰레드가 시작되면 수행되는 메소드 |

- Runnable 인터페이스를 구현한 클래스

```java
public class RunnableSample implements Runnable{
    public void run(){
        System.out.println("This is RunnableSample's run() method.");
    }
}
```

- Thread 클래스 확장한 예제

```java
public class ThreadSample extends Thread{
    public void run(){
        System.out.println("This is ThreadSample's run() method.");
    }
}
```

- 쓰레드를 수행하는 예제 - RunThreads 클래스

```java
public class RunThreads {
    public static void main(String[] args) {
        RunThreads threads = new RunThreads();
        threads.runBasic();
    }

    public void runBasic() {
        RunnableSample runnable = new RunnableSample();
        new Thread(runnable).start();

        ThreadSample thread = new ThreadSample();
        thread.start();
        System.out.println("RunThreads.runBasic() method is ended.");
    }
}
```

- 위의 코드에서 아래의 두 줄이 중요하다.
  - 쓰레드가 수행되는 우리가 구현하는 메소드는 run() 메소드다. → `new Thread(runnable).start();`
  - 쓰레드를 시작하는 메소드는 start()이다. → `thread.start();`

Rnnable 인터페이스를 구현하거나 Thread 클래스를 확장할 때에는 run() 메소드를 시작점으로 작성해야만 한다.

그런데

쓰레드를 시작하는 메소드는 `run()`이 아닌 `start()`라는 메소드다.

내가 `start()` 메소드를 만들지 않아도, 알아서 자바에서 `run()` 메소드를 수행하도록 되어 있다.

- RunnableSample을 시작한 코드
  - Runnable  인터페이스를 구현한 RunnableSample 클래스를 쓰레드로 바로 시작할 수 없다. 따라서, 이와같이 Thread 클래스의 생성자에 해당 객체를 추가하여 시작해 주어야만 한다.

```java
new Thread(runnable).start();
```

- ThreadSample을 시작한 클래스
  - ThreadSample 클래스의 객체에 바로 start() 메소드를 호출할 수 있다.

```java
thread.start();
```

쓰레드라는 것을 start() 메소드를 통해서 시작했다는 것은, 프로세스가 아닌 **`하나의 쓰레드를 JVM에 추가하여 실행한다는 것이다.`**

![Untitled](%E1%84%8A%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%85%E1%85%A1%E1%84%86%E1%85%A7%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%20%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%A1%E1%84%8B%E1%85%AD%20a014f0aaf0be46969497604a40fb2c06/Untitled%201.png)

그림처럼 쓰레드를 구현할 때, start() 메소드를 호출하면 쓰레드 클래스에 있는 run() 메소드의 내용이 종료되든 안되든 쓰레드를 시작한 메소드에서는 그 다음 줄에 있는 코드를 실행한다.

- `RunnableSample`, `ThreadSample` 각 5개씩 객체를 생성하여 실행한 예제

```java
public class RunMultiThreads {
    public static void main(String[] args) {
        RunMultiThreads sample = new RunMultiThreads();
        sample.runMultiThread();
    }

    public void runMultiThread() {
        RunnableSample []runnable = new RunnableSample[5];
        ThreadSample []thread = new ThreadSample[5];
        for (int loop = 0; loop < 5; loop++) {
            runnable[loop] = new RunnableSample();
            thread[loop] = new ThreadSample();

            new Thread(runnable[loop]).start();
            thread[loop].start();
        }
        System.out.println("RunMultiThread.runMultiThread() method is ended.");
    }
}
```

- 결과

```java
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
RunMultiThread.runMultiThread() method is ended.
This is ThreadSample's run() method.
```

위 결과를 보면 순차적으로 실행된 것이 아닌 걸 느낄 수 있다.


<!-- outline-end -->
