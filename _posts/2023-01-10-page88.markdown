---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: Java Thread에 관하여

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java]
# thumbnail image for post
img: ":java.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2023-01-10 18:20:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2023-01-10 18:20:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->

# Thread

자바 프로그램을 실행 후 적어도 하나의 JVM이 시작된다.

보통 JVM이 시작되면 자바 프로세스(Process)가 시작한다.  프로세스 안에서 여러 개의 쓰레드가 존재하고 있다.

![Untitled](%E1%84%8A%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%85%E1%85%A1%E1%84%86%E1%85%A7%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%20%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%A1%E1%84%8B%E1%85%AD%20a014f0aaf0be46969497604a40fb2c06/Untitled.png)

우리가 Java 클래스를 실행하는 순간 자바 프로세스가 시작되고, main()  메소드가 수행되면서 하나의 쓰레드가 시작되는 것이다.

만약 많은 쓰레드가 필요하다면,  main() 메소드에서 쓰레드를 생성해 주면 된다. 자바를 사용하여 웹을 제공할 때에는 Tomcat과 같은 WAS(Web Application Server)를 사용한다. 이 WAS도 똑같이 main() 메소드에서 생성한 쓰레드들이 수행되는 것이다.

- 쓰레드라는 것을 왜 만들었을까?

프로세스가 하나 시작하려면 많은 자원(resource)이 필요하다.

만약 하나의 작업을 동시에 수행하려고 할 때 여러 개의 프로세스를 띄워서 실행하면 각각 메모리를 할당하여 주어야만 한다.

JVM은 기본적으로 아무런 옵션 없이 실행하면 OS마다 다르지만, 적어도 `32MB ~ 64MB(Mega byte)` 의 물리 메모리를 점유한다.

반면에 쓰레드를 하나 추가하면 1MB 이내의 메모리를 점유한다.  따라서, 쓰레드를 `“경량 프로세스(lightweight process)”` 라고 부른다.

- Tip. Thread 번역

  Thread라는 단어의 사전적인 의미는 실타래를 의미한다고한다.


---

## Runnable 인터페이스와 Thread 클래스

쓰레드 생성하는 방법

1. Runnable 인터페이스를 사용하는 법
2. Thread 클래스를 사용하는 방법

Runnable 인터페이스와 Thread 클래스는 모두 `java.lang` 패키지에 있다.

Runnable 인터페이스에 선언되어 있는 메소드

| 리턴 타입 | 메소드 이름 및 매개 변수  | 설명 |
| --- | --- | --- |
| void | run() | 쓰레드가 시작되면 수행되는 메소드 |

- Runnable 인터페이스를 구현한 클래스

```java
public class RunnableSample implements Runnable{
    public void run(){
        System.out.println("This is RunnableSample's run() method.");
    }
}
```

- Thread 클래스 확장한 예제

```java
public class ThreadSample extends Thread{
    public void run(){
        System.out.println("This is ThreadSample's run() method.");
    }
}
```

- 쓰레드를 수행하는 예제 - RunThreads 클래스

```java
public class RunThreads {
    public static void main(String[] args) {
        RunThreads threads = new RunThreads();
        threads.runBasic();
    }

    public void runBasic() {
        RunnableSample runnable = new RunnableSample();
        new Thread(runnable).start();

        ThreadSample thread = new ThreadSample();
        thread.start();
        System.out.println("RunThreads.runBasic() method is ended.");
    }
}
```

- 위의 코드에서 아래의 두 줄이 중요하다.
  - 쓰레드가 수행되는 우리가 구현하는 메소드는 run() 메소드다. → `new Thread(runnable).start();`
  - 쓰레드를 시작하는 메소드는 start()이다. → `thread.start();`

Rnnable 인터페이스를 구현하거나 Thread 클래스를 확장할 때에는 run() 메소드를 시작점으로 작성해야만 한다.

그런데

쓰레드를 시작하는 메소드는 `run()`이 아닌 `start()`라는 메소드다.

내가 `start()` 메소드를 만들지 않아도, 알아서 자바에서 `run()` 메소드를 수행하도록 되어 있다.

- RunnableSample을 시작한 코드
  - Runnable  인터페이스를 구현한 RunnableSample 클래스를 쓰레드로 바로 시작할 수 없다. 따라서, 이와같이 Thread 클래스의 생성자에 해당 객체를 추가하여 시작해 주어야만 한다.

```java
new Thread(runnable).start();
```

- ThreadSample을 시작한 클래스
  - ThreadSample 클래스의 객체에 바로 start() 메소드를 호출할 수 있다.

```java
thread.start();
```

쓰레드라는 것을 start() 메소드를 통해서 시작했다는 것은, 프로세스가 아닌 **`하나의 쓰레드를 JVM에 추가하여 실행한다는 것이다.`**

![Untitled](%E1%84%8A%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%85%E1%85%A1%E1%84%86%E1%85%A7%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%20%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%A1%E1%84%8B%E1%85%AD%20a014f0aaf0be46969497604a40fb2c06/Untitled%201.png)

그림처럼 쓰레드를 구현할 때, start() 메소드를 호출하면 쓰레드 클래스에 있는 run() 메소드의 내용이 종료되든 안되든 쓰레드를 시작한 메소드에서는 그 다음 줄에 있는 코드를 실행한다.

- `RunnableSample`, `ThreadSample` 각 5개씩 객체를 생성하여 실행한 예제

```java
public class RunMultiThreads {
    public static void main(String[] args) {
        RunMultiThreads sample = new RunMultiThreads();
        sample.runMultiThread();
    }

    public void runMultiThread() {
        RunnableSample []runnable = new RunnableSample[5];
        ThreadSample []thread = new ThreadSample[5];
        for (int loop = 0; loop < 5; loop++) {
            runnable[loop] = new RunnableSample();
            thread[loop] = new ThreadSample();

            new Thread(runnable[loop]).start();
            thread[loop].start();
        }
        System.out.println("RunMultiThread.runMultiThread() method is ended.");
    }
}
```

- 결과

```java
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
RunMultiThread.runMultiThread() method is ended.
This is ThreadSample's run() method.
```

위 결과를 보면 순차적으로 실행된 것이 아닌 걸 느낄 수 있다.

새로 생성한 쓰레드는 run() 메소드가 종료되면 끝난다.

---

## Thread 클래스의 생성자

| 생성자 | 설명 |
| --- | --- |
| Thread() | 새로운 쓰레드를 생성한다.  |
| Thread(Runnable target) | 매개 변수로 받은 target 객체의 run() 메소드를 수행하는 쓰레드를 생성한다. |
| Thread(Runnable target, String name) | 매개 변수로 받은 target 객체의 run() 메소드를 수행하고, name이라는 이름을 갖는 쓰레드를 생성한다. |
| Thread(String name) | name이라는 이름을 갖는 쓰레드를 생성한다. |
| Thread(ThreadGroup group, Runnable target) | 매개 변수로 받은 group의 쓰레드 그룹에 속하는 target 객체의 run() 메소드를 수행하는 쓰레드를 생성한다. |
| Thread(ThreadGroup group, Runnable target, String name) | 매개 변수로 받은 group의 쓰레드 그룹에 속하는 target 객체의 run() 메소드를 수행하고, name이라는 이름을 갖는 쓰레드를 생성한다. |
| Thread(ThreadGroup group, Runnable target, String name, long stackSize) | 매개 변수로 받은 group의 쓰레드 그룹에 속하는 target 객체의 run() 메소드를 수행하고, name이라는 이름을 갖는 쓰레드를 생성한다.단 해당 쓰레드의 스택의 크기는 stackSize만큼만 가능하다. |
| Thread(ThreadGroup group, String name) | 매개 변수로 받은 group의 쓰레드 그룹에 속하는 name이라는 이름을 갖는 쓰레드를 생성한다. |
- 모든 쓰레드는 이름이 있음. (이름을 지정하지 않을 경우 `"Thread-n"` 으로 명명된다. )
- n은 쓰레드가 생성된 순서에 따라 증가한다.
- 이름을 지정할 경우, 만약 쓰레드 이름이 겹친다고 해도 예외나 에러가 발생하지 않는다.

- ThreadGroup은 쓰레드를 생성할 때 쓰레드를 묶어 놓을 수 있다.
- 쓰레드를 그룹으로 묶으면 ThreadGroup 클래스에서 제공하는 여러 메소드를 통해서 각종 정보를 얻을 수 있다.

- 생성자에서 stackSize라는 값은 스택(stack)의 크기를 이야기한다. 쓰레드에서 얼마나 많은 메소드를 호출하는지, 얼마나 많은 쓰레드가 동시에 처리되는지는 JVM이 실행되는 OS의 플랫폼에 따라서 매우 다르다.

- 참고

  여기서 이야기하는 스택은 Collection 설명시 이야기한 Stack이라는 클래스와 전혀 상관 없다. 자바 프로세스가 시작되면 실행 데이터 공간(Runtime data area)이 구성된다. 그 중 하나가 스택이라는 공간이며, 쓰레드가 생성될 때마다 별도의 스택이 할당된다.


```java
public class NameThread extends Thread{
    public NameThread(){

    }

    public void run(){

    }
}
```

NameThread라는 클래스가 Thread 클래스를 확장함. 아무 매개 변수도 없는 Thread() 생성자를 사용하는 것과 동일하다.

만약 쓰레드의 이름을 “ThreadName”으로 지정하고 싶다면, 아래와 같이 NameThread의 생성자를 하면된다.

```java
public NameThread(){
    super("ThreadName");
}
```

Thread(String name)을 호출한 것과 동일한 효과를 본다.

“ThreadName” 이라고 지정해주면, 이 쓰레드 객체를 갯수 제한없이 계속 만들어도 동일한 “ThreadName”이쓰레드를 만들 수 있다.


<!-- outline-end -->
