---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title:  람다 표현식(2)

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java, Design Pattern, Modern Java in action]
# thumbnail image for post
img: ":ModernJava.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-09-03 23:50:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-09-03 23:50:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# Chapter03-2

## 람다 표현식을 조합할 수 있는 유용한 메서드

### Comparator조합

정적 메서드 Comparator.comparing을 이용해서 비교에 사용할 키를 추출하는 Funtion 기반의 Comparator를 반환할 수 있다.

```java
Comparator<Apple> c = Comparator.comparing(Apple::getWeight);
```

- 역정렬

사과의 무게를 내림차순으로 하고 싶다면 어떻게 해야할까 ?

다른 Comparator 인스턴스를 만들 필요가 없다. 인터페이스 자체에서 주어진 비교자의 순서를 뒤바꾸는 reverse라는 디폴트 메서드를 제공하기 때문이다. 따라서 처음 비교자 구현을 그대로 재사용해서 사과의 무게를 기준으로 역정렬할 수 있다.

➡️코드

```java

System.out.println("---------역정렬---------");
inventory.sort(comparing(Apple::getWeight).reversed()); //<-- 무게를 내림차순으로 정렬
```

➡️출력 결과

```java
---------역정렬---------
[Apple{color=GREEN, weight=150}, Apple{color=RED, weight=120}, Apple{color=GREEN, weight=80}]
```

➡️코드

```java
System.out.println("---------정렬---------");
inventory.sort(comparing(Apple::getWeight)); // 디폴트로 오름차순으로 되어있다.!
System.out.println(inventory);
```

➡️출력 결과

```java
---------정렬---------
[Apple{color=GREEN, weight=80}, Apple{color=RED, weight=120}, Apple{color=GREEN, weight=150}]
```

- Comparator 연결

위 코드를 하면서 의문점이 하나 들었다. 사과의 무게가 같은 것들이 있는 것은 어떻게 처리할까 ? 정렬된 리스트에서 어떤 사과를 먼저 나열해야할까 ?

비교 결과를 더 다듬을 수 있는 두 번째 Comparator를 만들 수 있다.

예를들면 - 두 사과를 비교한 다음에 무게가 같다면 `원산지 국가별`로 사과를 정렬할 수 있다. `thenComparing` 메서드로 두 번째 비교자를 만들 수 있다. `thenComparing`은 (comparing 메서드처럼) 함수를 인수로 받아 첫 번째 비교자를 이용해서 두 객체가 같다고 판단되면 두 번째 비교자에 객체를 전달한다.

![Untitled](https://user-images.githubusercontent.com/56623911/188275812-7a4bf2db-621e-4aeb-a545-ef3573c6aabf.png)

백문이 불여일타 ! 코드를 통해서 보자!

```java
inventory.sort(comparing(Apple::getWeight)
				 .reversed() // <-- 무게를 내림차순으로 정렬
				 .thenComparing(Apple::getCountry)); //<-- 두 사과의 무게가 같으면 국가별로 정렬
```

➡️출력 결과

```java
--------같은 무게가 존재한다면 ? ---------
[Apple{color=RED, weight=150, country=KOREA},
 Apple{color=GREEN, weight=150, country=USA},
Apple{color=RED, weight=120, country=JAPAN},
Apple{color=GREEN, weight=80, country=KOREA}]
```

### Predicate 조합

Predicate 인터페이스는 복잡한 프레디케이트를 만들 수 있도록 `negate`, `and`, `or` 세 가지 메서드를 제공한다.

예를 들어 ‘빨간색이 아닌 사과’처럼 특정 프레디케이트를 반전시킬 때 `negate`메서드를 사용할 수 있다.

```java
//기존 프레디케이트 객체 redApple의 결과를 반전시킨 객체를 만든다.
Predicate<Apple> notRedApple = redApple.negate();
```

- `and` 메서드를 이용해서 ‘빨간색이면 무거운 사과를 선택’하도록 두 람다를 조합할 수 있다.

```java
// 두 프레디케이트를 연결해서 새로운 프레디케이트 객체를 만든다.
Predicate<Apple> redAppleHeavyApple = redApple.and(apple → apple.getWeight() > 150);
```

- `or`  메서드를 이용해서 ‘빨간색이면 무거운(150g 이상) 사과 또는 그냥 녹색 사과' 등 다양한 조건을 만들 수 있다.

```java
//프레디케이트 메서드를 연결해서 더 복잡한 프레디케이트 객체를 만든다.
Predicate<Apple> redAndHeavyAppleOrGreen =
			redApple.and(apple -> apple.getWeight() > 150)
							.or(apple -> GREEN.equals(a.getColor()));

```

- 이것이 대단한 일인 이유가 뭘까 ?

단순한 람다 표현식을 조합해서 더 복잡한 람다  표현식을 만들 수 있기 때문이다. 심지어 람다 표현식을 조합해도 코드 자체가 문제를 잘 설명한다는 점은 변치 않는다.

여기서 소개한 `and`, `or` 등은 왼쪽에서 오른쪽으로 연결되었다. 즉, `a.or(b).and(c)` 는 `(a || b) && c`와 같다.



---

### Function 조합

Function 인터페이스에서 제공하는 람다 표현식도 조합할 수 있다. Function인터페이스는 Function 인스턴스를 반환하는 `andThen`, `compose` 두 가지 디폴트 메서드를 제공한다.

- `andThen` 메서드는 주어진 함수를 먼저 적용한 결과를 다른 함수의 입력으로 전달하는 함수를 반환한다.

예를 들어 숫자를 증가(x → x + 1)시키는 f라는 함수가 있고, 숫자에 2를 곱하는 g라는 함수가 있다고 가정하자.

f와 g를 조합해서 숫자를 증가시킨 뒤 결과에 2를 곱하는 h라는 함수를 만들 수 있다.

```java
Function<Integer, Integer> f = x ->x + 1;
Function<Integer, Integer> g = x ->x * 2;
Function<Integer, Integer> h = f.andThen(g); // <-- 수학으로는 write g(f(x)) 또는 (g o f)(x)라고 표현
int result = h.apply(1); // <- 4를 반환
```

- `compose` 메서드는 인수로 주어진 함수를 먼저 실행한 다음에 그 결과를 외부 함수의 인수로 제공한다. 즉, f.andThen(g)에서 andThen 대신에 compose를 사용하면 g(f(x))가 아니라 f(g(x))라는 수식이 된다.

```java
Function<Integer, Integer> f = x ->x + 1;
Function<Integer, Integer> g = x ->x * 2;
Function<Integer, Integer> h = f.compose(g); //<-- 수학으로는 f(g(x))또는 (f o g)(x)라고 표현
int result = h.apply(1); //<-- 3을 반환
```

- andThen 과 compose의 차이

![Untitled 1](https://user-images.githubusercontent.com/56623911/188275800-548cdf1e-a93c-422d-856a-b1be917d254b.png)

![Untitled 2](https://user-images.githubusercontent.com/56623911/188275805-1c493d26-7f01-4d70-b5c8-1d6093a8393c.png)

이해가 안된다!…  다른 예제를 통해서 한번 더 해보자.

예를 들어  문자열로 구성된 편지 내용을 변환하느 다양한 유틸리티 메서드가 있다고 가정하자.

```java
public class Letter{
	public static String addHeader(String text){
		return "From Raoul, Mario and Alan: " + text;
	}

	public static String addFooter(String text){
		return text + " Kind regards";
	}

	public static String checkSpelling(String text){
		return text.replaceAll("labda", "lambda");
	}
}
```

여러 유틸리티 메서드를 조합해서 다양한 변환 파이프라인을 만들 수 있다. 헤더를 추가(addHeader)한 다음에, 철자검사(checkSpelling)를 하고 마지막에 푸터를 추가(addFooter)할 수 있다.

```java
Function<String, String> addHeader = Letter::addHeader;
Function<String, String> transformationPipeline =
				addHeader.andThen(Letter::checkSpelling)
							   .andThen(Letter::addFooter);

```

![Untitled 3](https://user-images.githubusercontent.com/56623911/188275807-2ed97fcd-7e69-4cdc-a8fe-56d49f61cb56.png)

응용 : 철자 검사빼고 헤더와 푸터만 추가하는 파이프라인

```java
Function<String, String> addHeader = Letter::addHeader;
Function<String, String> transformationPipeline =
				addHeader.andThen(Letter::addFooter);
```

## 비슷한 수학적 개념

### 적분

다음과 같은 함수 (자바의 함수가 아닌 수학의 함수) f 가 있다고 가정하자.

$f(x) = x + 10$

공학에서는 함수가 차지하는 영역을 묻는 질문이 자주 등장한다.(일반적으로 x축이 기준선이 됨.)

$\textstyle \int_3^7 f(x)dx$  또는  $\textstyle \int_3^7 (x + 10)dx$

- x가 3에서 7까지의 범위일 때 함수  $f(x) = x + 10$ 의 영역

![Untitled 4](https://user-images.githubusercontent.com/56623911/188275808-d10a3d18-27a9-4cf5-9608-d5ae0d4b0023.png)

이 예제에서 함수 f는 직선이므로 사다리꼴 기법(기본적으로 삼각형으로 구성되는)으로 정답을 찾는다.

$\frac12 \ast ((3 + 10) + (7 + 10)) \ast (7 - 3) = 60$

이 공식을 자바코드로 표현해보자.  우선 dy / dx 기호를 어떻게 처리할 것인가 ?

우선은 f와 한계값(여기서 3.0과 7.0)을 인수로 받는 integrate라는 함수를 만들어야한다.  즉, 다음처럼 함수 f를 인수로 받는 함수를 자바로 구현할 수 있다.

```java
integrate(f, 3, 7)
```

그러나 다음처럼 간단히 구현할 수 없다.

```java
integrate(x + 10, 3, 7)
```

우선 이  식에서 x의 범위가 불분명하다. 그리고 f를 전달하는 것이 아니라 x + 10 이라는 값을 전달하게 되기 때문에 잘못된 식이다.

수학에서 dx는 `‘x를 인수로 받아 x + 10의 결과를 만드는 함수'` 로 정리할 수 있다.

### 자바 8 람다로 연결 !

자바 8에서는 (double x) → x + 10 같은 람다 표현식을 사용할 수 있다.

따라서 함수 f를 다음처럼 구현할 수 있다.

```java
integrate((double x) -> x + 10, 3, 7)
```

또는

```java
integrate((double x) -> f(x), 3, 7)
```

C가 정적 메서드 f를 포함하는 클래스라 가정하면  메서드 참조를 사용해서 코드를 더 간단하게 만들 수 있다.

f의 코드를 integrate 메서드로 전달하는 것이 이 예제의 핵심.

```java
integrate(C::f, 3, 7)
```

이제 integrate 메서드를 구현해보자. f를 선형 함수(직선)이라고 가정하자.

```java
//틀린 자바 코드 ! 자바코드를 수학 함수처럼 구현할 수 없다.
public double integrate((double -> double) f, double a, double b) {
	return (f(a) + f(b)) * (b - a) / 2.0
}
```

하지만 함수형 인터페이스(여기서는 DoubleFunction)를 기대하는 콘텍스트에서만 람다 표현식을 사용할 수 있으므로 다음처럼 코드를 구현해야 한다.

```java
public double integrate(DoubleFunction<Double>) f, double a, double b){
	return (f.apply(a) + f.apply(b)) * (b - a) / 2.0;
}
```

또는  DoubleUnaryOperator를 이용해도 결과를 박싱할 필요가 없다.

```java
public double integrate(DoubleUnaryOperator f, double a, double b){
	return (f.applyAsDouble(a) + f.applyAsDouble(b)) * (b - a) / 2.0;
}
```

참고로 수학처럼 f(a)라는 표현할 수없고 f.apply(a)라고 구현했는데 이는 자바가 진정으로 함수를 허용하지 않고 모든 것을 객체로 여기는 것을 포기할 수 없기 때문이다.

![Untitled 5](https://user-images.githubusercontent.com/56623911/188275810-b00bda2e-3a78-4b7a-9521-7d1d9c63b561.png)

회고록

람다 표현식(2) - 메소드 레퍼런드, 람다 표현식을 조합할 수 있는 유용한 메서드, Comparator, Predicate, Function , 비슷한 수학적 개념 등 을 배웠다.<br>
이론은 이해는 한걸까? 모르는 사람에게 이해되게 설명해서 체크해봐야겠다.
다음은 난이도가 높은 응용 및 적용.. 어렵다.. 여러워야지 하나씩 뿌수면서하는 묘미가 있다.
예제를 해보고 내가 구상한 것들을 코드로 적용 및 응용을 해보자.. 천천히 나아가 보자.   배우는 건 상대적으로 늦지만 꾸준히하는 것을 누구보다 잘 할 자신이 있다.

![giphy](https://user-images.githubusercontent.com/56623911/188276149-a51fdf7e-ac93-448d-86ed-be416d68a039.gif)


<!-- outline-end -->
