---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: Thymeleaf 기본 문법 정리

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible
tags: [Effective_Java, Java]
# thumbnail image for post
img: ":thymeleaf.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2023-03-18 23:11:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2023-03-18 23:11:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->

# 타임리프 - 기본기능

## Thymeleaf 특징

- 서버 사이드 HTML 렌더링 (SSR)
- 네츄럴 템플릿(natural templates)
- 스프링 통합 지원

---

## ➡️타임리프 기본 기능

### ✅타임리프 사용 선언

```java
<html xmlns:th="http://www.thymeleaf.org">
```

### ✅기본 표현식

- 간단한 표현
  - 변수 표현식 : ${…}
  - 선택 변수 표현식 : *{…}
  - 메시지 표현식 : #{…}
  - 링크 URL 표현식: @{…}
  - 조각 표현식 : ~{…}

- 리터럴
  - 텍스트 : ‘one text’, ‘Another one!’, …
  - 숫자 : 0, 1, 3.2, 11.0, ….
  - 불린 : true, false
  - 널 : null
  - 리터럴 토큰 : one, sometext, main, …

- 문자 연산 :
  - 문자 합치기 : +
  - 리터럴 대체 : |Hello ${name}|

- 산술 연산 :
  - Binary operators : +, -, *, /, %
  - Minus sign (unary operator) : -

- 불린 연산
  - Binary operators : and, or
  - Boolean negation (unary operator) : !, not

- 비교와 동등
  - 비교 : >, <, ≥, ≤   (  gt, le ,ge, le)
  - 동등 연산  : ==, ≠ (eq, ne)

- 조건 연산
  - If-then : (if) ? (then)
  - if-then-else : (if) ? (then) : (else)
  - Default :  (value) ?: defaultvalue)

- 특별한 토큰 :
  - No-Operation : _

출처 - [Thymleaf 기본기능](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax)

---

## ➡️텍스트 - text, utext

타임리프는 기본적으로 HTML 태그의 속성에 기능을 정의해서 동작한다. HTML의 콘텐츠(Content)에 데이터를 출력할 때는 다음과 같이 `th:text` 를 사용한다.

`<span th:text="${data}">`

HTML 태그의 속성이 아니라 HTML 콘텐츠 영역안에서 직접 데이터를 출력하고 싶으면 다음과 같이 사용한다

`[[...]]`

컨텐츠 안에서 직접 출력하기  = `[[${data}]]`

---

## Escape

HTML문서는 `<` , `>` 같은 특수 문자를 기반으로 정의된다. 따라서 뷰 템플릿으로 HTML 화면을 생성할 때는 출력하는 데이터에 이러한 특수 문자가 있는 것을 주의해서 사용해야 한다.

<b> 태그를 사용해서 **Srping!** 이라는단어가 굵게 나오게 해보자.

```java
@GetMapping("text-basic")
public String textBasic(Model model) {
    model.addAttribute("data", "hello <b>Spring!</b>");
    return "basic/text-basic";
}
```

- 페이지 소스를 보면 아래와 같이 나온다.

```java
<li>th:text 사용 <span>hello &lt;b&gt;Spring!&lt;/b&gt;</span></li>
```

개발자가 의도한 것은 `<b>` 가 있으면 해당 부분을 강조하는 것이 목적이었다. <b> 태그 그대로 나온다.

소스 보기를 하면 `<` 부분이 `&lt;`로 변경된 것을 알 수 있다.

### ⚠️HTML 엔티티

웹 브라우저는 `<` 를 HTML 태그의 시작으로 인식한다. 따라서 `<` 를 태그의 시작이 아니라 문자로 표현할 수 있는 방법이 필요한데, 이것을 HTML 엔티티라 한다. 그리고 이렇게 HTML에서 사용하는 특수 문자를 HTML 엔티티로 변경하는 것을 이스케이프(escape)라 한다.

타임리프가 제공하는 `th:text`, `[[...]]` 는 기본적으로 이스케이프(escape)를 제공한다.

| 엔티티 문자 | 엔티티 이름 | 16진수 엔티티 숫자 | 설명 |
| --- | --- | --- | --- |
|   | &nbsp; | &#160; | 줄 바꿈 없는 공백 |
| < | &lt; | &#60; | 보다 작은 |
| > | &gt; | &#62; | 보다 큰 |
| & | &amp; | &#38; | AND 기호 |
| " | &quot; | &#34; | 큰따옴표 |
| ' | &apos; | &#39; | 작은따옴표 |

[Character entity references in HTML](https://www.w3.org/TR/html4/sgml/entities.html)

### ⚠️Unescape

이스케이프 기능을 사용하지 않으려면 어떻게 해야할까?

타임리프는 다음 두 기능을 제공한다.

- `th:text` → `th:utext`
- `[[...]]` → `[(...)]`

---

## ➡️SpringEL 다양한 표현식 사용

### 1️⃣Object

- `user.username` : user의 username을 프로퍼티 접근 → `user.getUsername()`
- `user[’username’]` : 위와 같음 → `user.getUsername()`
- `user.getUsername()` : user의 `getUsername()` 을 직접 호출

## 2️⃣ List

- `users[0].username` : List에서 첫 번째 회원을 찾고 username 프로퍼티 접근 → `list.get(0).getUsername()`
- `users[0][’username’]` :  위와 같음
- `users[0].getUsername()` : List에서 첫 번째 회원을 찾고 메서드 직접 호출

## 3️⃣Map

- `userMap['userA'].username` :  Map에서 userA를 찾고, username 프로퍼티 접근 → `map.get("userA").getUsername()`
- `userMap['userA']['username']` : 위와 같음
- `userMap['userA'].getUsername()` : Map에서 userA를 찾고 메서드 직접 호출

```html
<h1>SpringEL 표현식</h1>
<ul>
    <li>${user.username} = <span th:text="${user.username}"></span></li>
    <li>${user['username']} = <span th:text="${user['username']}"></span></li>
    <li>${user.getUsername()} = <span th:text="${user.getUsername()}"></span></li>

</ul>
<ul>list
    <li>${users[0].username = <span th:text="${users[0].username}"></span></li>
    <li>${users[0]['username']} = <span th:text="${users[0]['username']}"></span></li>
    <li>${users[0].getUsername()} = <span th:text="${users[0].getUsername()}"></span></li>
</ul>

<ul>Map
    <li>${userMap['userA'].username = <span th:text="${userMap['userA'].username}"></span></li>
    <li>${userMap['userA']['username']} = <span th:text="${userMap['userA']['username']}"></span></li>
    <li>${userMap['userA'].getUsername()} = <span th:text="${userMap['userA'].getUsername()}"></span></li>
</ul>
```

- 화면 출력

<img width="476" alt="Untitled" src="https://user-images.githubusercontent.com/56623911/226534543-dd161da2-54e8-4e0e-b1f2-008b245aad16.png">

### 지역변수 선언

`th:with` 를 사용하면 지역 변수를 선언해서 사용할 수 있다. 지역 변수는 선언한 태그 안에서만 사용할 수 있다.

```html
<h1>지역 변수 - (th:with)</h1>
<div th:with="first=${users[0]}">
    <p>처음 사람의 이름은 <span th:text="${first.username}"></span></p>
</div>
```

- 화면 출력

<img width="350" alt="Untitled 1" src="https://user-images.githubusercontent.com/56623911/226534496-cb53f600-185b-48d9-b517-5101e011e175.png">

---

## ➡️기본 객체들

타임 리프는 기본 객체들을 제공한다.

- `${#request}` : 스프링 부트 3.0부터 제공하지 않는다.
- `${#response}` : 스프링 부트 3.0부터 제공하지 않는다.
- `${session}` : 스프링 부트 3.0부터 제공하지 않는다.
- `${servletContext}` : 스프링 부트 3.0부터 제공하지 않는다.
- `${#locale}`

### ⚠️주의- 스프링 부트 3.0

스프링 부트 3.0부터는 `${#request}`, `${#response}` , `${session}`, `${servletContext}` 를 지원하지 않는다. 만약 사용하게 되면 다음과 같은 오류가 발생한다.

```
Caused by: java.lang.IllegalArgumentException: The
'request','session','servletContext' and 'response' expression utility objects
are no longer available by default for template expressions and their use is
not recommended. In cases where they are really needed, they should be manually
added as context variables.
```

스프링 부트 3.0이라면 직접 `model` 에 해당 객체를 추가해서 사용해야 한다.

스프링 부트 2.5.0으로 예제를 진행

`#request` 는 `HttpServletRequest` 객체가 그대로 제공되기 때문에 데이터를 조회하려면 `request.getParameter(”data”)` 처럼 불편하게 접근해야 한다.

이런 점을 해결하기 위해 편의 객체도 제공한다.

- HTTP 요청 파라미터 접근 : `param`
  - 예) `${param.paramData}`

- HTTP 세션 접근 : `session`
  - 예) `${session.sessionData}`

- 스프링 빈 접근 : `@`
  - 예) `${@helloBean.hello('Spring!')}`

### ✅식 기본 객체

```html
<h1>식 기본 객체 (Expression Basic Objects)</h1>
<ul>
    <li>request = <span th:text="${#request}"></span></li>
    <li>response = <span th:text="${#response}"></span></li>
    <li>session = <span th:text="${#session}"></span></li>
    <li>servletContext = <span th:text="${#servletContext}"></span></li>
    <li>locale = <span th:text="${#locale}"></span></li>
</ul>
```

- 화면 출력

<img width="646" alt="Untitled 2" src="https://user-images.githubusercontent.com/56623911/226534505-d425e659-5d99-4671-90ab-357e178fd9f4.png">

### ✅편의 객체

```html
<h1>편의 객체 </h1>
<ul>
    <li>Request Parameter = <span th:text="${param.paramData}"></span></li>
    <li>session = <span th:text="${session.sessionData}"></span></li>
    <li>spring bean = <span th:text="${@helloBean.hello('Spring!')}"></span></li>
</ul>
```

<img width="542" alt="Untitled 3" src="https://user-images.githubusercontent.com/56623911/226534509-2be6319a-738a-43a2-82cb-7f8ec8a14030.png">

---

## ➡️유틸리티 객체와 날짜

타임리프는 문자, 숫자, 날짜, URI 등을 편리하게 다루는 다양한 유틸리티 객체들을 제공한다.

### 타임리프 유틸리티 객체들

- `#message` : 메시지, 국제화 처리
- `#uris` : URI 이스케이프 지원
- `#dates` : `[java.util.Date](http://java.util.Date)` 서식 지원
- `#calendars` : `java.util.Calendar` 서식 지원
- `#temporals` : 자바8 날짜 서식 지원
- `#numbers` : 숫자 서식 지원
- `#strings` : 문자 관련 편의 기능
- `#objects` : 객체 관련 기능 제공
- `#bools` : boolean 관련 기능 제공
- `#arrays` 배열 관련 기능 제공
- `lists`, `#sets` , `#maps` : 켈력션 관련 기능 제공
- `#ids` : 아이디 처리 관련 기능 제공

> 참고 : [타임리프 유틸리티 객체](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#expression-utility-objects)

참고 : [유틸리티 객체 예시](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#appendix-b-expression-utility-objects)
>

### 🗓️자바8 날짜

타임리프에서 자바8 날짜인 `LocalDate`, `LocalDateTime` , `Instant` 를 사용하려면 추가 라이브러리가 필요하다. 스프링 부트 타임리프를 사용하면 해당 라이브러리가 자도응로 추가되고 통합된다.

### ✅타임리프 자바8 날짜 지원 라이브러리

- `thymeleaf-extras-java8time`

```html
<h1>LocalDateTime</h1>
<ul>
  <li>default = <span th:text="${localDateTime}"></span></li>
  <li>yyyy-MM-dd HH:mm:ss = <span th:text="${#temporals.format(localDateTime,'yyyy-MM-dd HH:mm:ss')}"></span></li>
</ul>
```

- 화면 출력

<img width="584" alt="Untitled 4" src="https://user-images.githubusercontent.com/56623911/226534515-6bcd6321-cd81-44ac-a129-fcf837536f33.png">

### ✅자바8 날짜용 유틸리티 객체

`#temporals`

```html
<h1>LocalDateTime - Utils</h1>
<ul>
  <li>${#temporals.day(localDateTime)} = <span th:text="${#temporals.day(localDateTime)}"></span></li>

  <li>${#temporals.month(localDateTime)} = <span th:text="${#temporals.month(localDateTime)}"></span> </li>
  <li>${#temporals.monthName(localDateTime)} = <span th:text="${#temporals.monthName(localDateTime)}"></span></li>
  <li>${#temporals.monthNameShort(localDateTime)} = <span th:text="${#temporals.monthNameShort(localDateTime)}"></span></li>

  <li>${#temporals.year(localDateTime)} = <span th:text="${#temporals.year(localDateTime)}"></span></li>
  <li>${#temporals.dayOfWeek(localDateTime)} = <span th:text="${#temporals.dayOfWeek(localDateTime)}"></span></li>
  <li>${#temporals.dayOfWeekName(localDateTime)} = <span th:text="${#temporals.dayOfWeekName(localDateTime)}"></span> </li>
  <li>${#temporals.dayOfWeekNameShort(localDateTime)} = <span th:text="${#temporals.dayOfWeekNameShort(localDateTime)}"></span> </li>

  <li>${#temporals.hour(localDateTime)} = <span th:text="${#temporals.hour(localDateTime)}"></span></li>
  <li>${#temporals.minute(localDateTime)} = <span th:text="${#temporals.minute(localDateTime)}"></span></li>
  <li>${#temporals.second(localDateTime)} = <span th:text="${#temporals.second(localDateTime)}"></span></li>
  <li>${#temporals.nanosecond(localDateTime)} = <span th:text="${#temporals.nanosecond(localDateTime)}"></span></li>

</ul>
```

- 화면 출력

<img width="518" alt="Untitled 5" src="https://user-images.githubusercontent.com/56623911/226534519-46e2ea86-aaf3-4563-9719-217802f8b6c9.png">

---

## ➡️URL 링크

타임리프에서 URL을 생성할 때는 `@{…}` 문법을 사용하면 된다.

### 1️⃣단순 URL

- `@{/hello}` → `/hello`

### 2️⃣쿼리 파라미터

- `@{/hello(param1=${param1}, param2=${param2})}` → `/hello?param1=date1&param2=date2`
- `( )` 에 있는 부분은 쿼리 파라미터로 처리된다.

### 3️⃣ 경로 변수

- `@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}` → `/hello/data1/data2`
- URL 경로상에 변수가 있으면 `( )` 부분은 경로 변수로 처리된다.

### 4️⃣ 경로 변수 + 쿼리 파라미터

- `@{/hello/{param1}(param1=${param1}, param2=${param2})}` → `/hello/data1?param2=data2`
- 경로 변수와 쿼리 파라미터를 함께 사용할 수 있다.

상대 경로, 절대 경로, 프로토콜 기준을 표현할 수 도 있다.

- `/hello` : 절대 경로
- `hello` : 상대 결로

```html
<h1>URL 링크</h1>
<ul>
    <li><a th:href="@{/hello}">basic</a></li>
    <li><a th:href="@{/hello(param1=${param1}, param2=${param2})}">hello query parma</a></li>
    <li><a th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}">path variable + query parameter</a></li>
</ul>
```

---

## 리터럴(Literals)

리터럴은 소스 코드상에 고정된 값을 말하는 용어이다.

### ✅타임리프 리터널

- 문자 : `hello`
- 숫자 : `10`
- 불린 :  `true` , `false`
- null : `null`

⚠️타임리프에서 문자 리터럴은 항상 `'` (작은 따옴표)로 감싸야 한다.

`<span th:text="'hello'">`

그런데 문자를 항상 `'` 로 감싸는 것은 귀찮고 실수가 많아 진다. 공백 없이 쭉 이어진다면 하나의 의미있는 토큰으로 인지해서 다음과 같이 작은 따옴표를 생략할 수 있다.

Role : `A-Z` , `a-z`, `0-9`, `[ ]` , `.` , `-`, `_`

`<span th:text=”hello”>`

### ⚠️오류

`<span th:text:"hello world!"></span>`

문자 리터럴은 항상 원칙상 `'` 로 감싸야 한다. 중간에 공백이 있어서 하나의 의미있는 토큰으로도 인식되지 않는다.

### ✂️수정

`<span th:text="'hello world!'"></span>`

이렇게 `'` 로 감싸면 정상 동작한다.

```html
<h1>리터럴 </h1>
<ul>
    <li>'hello' + ' world!' = <span th:text="'hello' + 'world!'"></span></li>
    <li>'hello world!' = <span th:text="'hello world!'"></span></li>
    <li>'hello ' + ${data} = <span th:text="'hello' + ${data}"></span></li>
    <li>리터럴 대체 |hello ${data}| = <span th:text="|hello ${data}|"></span></li>
</ul>
```

⚠️주의 - `<li>”hello world!” = <span th:text=”hello world!”></span></li>` → 결과: 예외 발생

- 화면 출력

<img width="686" alt="Untitled 6" src="https://user-images.githubusercontent.com/56623911/226534522-f3911b3a-e803-485f-9ad9-0a8ec8e3fb2d.png">

---

## ➡️연산

타임리프 연산은 자바와 크게 다르지 않다. HTML 안에서 사용하기 때문에 HTML 엔터티를 사용하는 부분만 주의하자.

```html
<h1>연산</h1>
<ul>
    <li>산술연산
        <ul>
            <li>10 + 2 = <span th:text="10 + 2"></span></li>
            <li>10 % 2 == 0 :  <span th:text="10 % 2 == 0"></span></li>
        </ul>
    </li>
    <li>비교 연산
        <ul>
            <li>1 > 10 결과 :  <span th:text="1 &gt; 10"></span></li>
            <li>1 gt 10  결과 :  <span th:text="1 gt 10"></span></li>
            <li>1 >= 10 결과 :  <span th:text="1 >= 10"></span> </li>
            <li>1 ge 10 결과 :  <span th:text="1 ge 10"></span></li>
            <li>1 == 10 결과 :  <span th:text="1 == 10"></span></li>
            <li>1 != 10 결과 : <span th:text="1 != 10"></span></li>
        </ul>
    </li>

    <li>조건식
        <ul>
            <li>(10 % 2 == 0) ? '짝수' : '홀수' = <span th:text="(10 % 2 == 0) ? '짝수':'홀수'"></span></li>
        </ul>
    </li>

    <li>Elvis 연산자
        <ul>
            <li>${data}? : '데이터가 없습니다.' = <span th:text="${data}?: '데이터가 없습니다.'"></span></li>
            <li>${nullDate}? : '데이터가 없습니다.' = <span th:text="${nullData}?: '데이터가 없습니다.'"></span></li>
        </ul>
    </li>

    <li>No-Operation
        <ul>
            <li>${data}?: _ = <span th:text="${data}?: _">데이터가 없습니다.</span></li>
            <li>${nullData}?: _=<span th:text="${nullData}?: _">데이터가 없습니다.</span></li>
        </ul>

    </li>

</ul>
```

- 화면 출력

<img width="720" alt="Untitled 7" src="https://user-images.githubusercontent.com/56623911/226534526-cb2fbea7-8b38-4be5-ada7-190aff789c9e.png">

- 비교 연산 : HTML 엔티티를 사용해야 하는 부분을 주의하자.
  - `>` (gt), `<`(lt), `≥`(ge), `≤`(le), `!`(not), `==`(eq), `≠`(neq, ne)
- 조건식 : 자바의 조건식과 유사
- Elvis 연산자 : 조건식 편의 버전
- No-Operation : `_` 인 경우 마치 타임리프가 실행되지 않는 것 처럼 동작한다. 이것을 잘 사용하면 HTML의 내용 그대로 활용할 수 있다. 마지막 예를 보면 데이터가 없다. 부분이 그대로  출력된다.



---

## ➡️속성 값 설정

타임리프 태그 속성(Attribute)

타임림프는 주로 HTML 태그에 `th:*` 속성을 지정하는 방식으로 동작한다.

`th:*` 로 속성을 적용하면 기존 속성을 대체한다. 기존 속성이 없으면 새로 만든다.

- 렌더링 전 타임리프 소스코드

```html
<h1>속성 설정</h1>
  <input type="text" name="mock" th:name="userA"/>
```

- 타임리프가 렌더링 되고 난 후 페이지 소스

```html
<h1>속성 설정</h1>
  <input type="text" name="userA"/>
```

### ✅속성 추가

- 렌더링 전 타임리프 소스코드

```html
<h1>속성 추가</h1>
  - th:attrappend = <input type="text" class="text" th:attrappend="class=' large'"/><br/>
  - th:attrappend = <input type="text" class="text" th:attrprepend="class='large '"/><br/>
  - th:classappend = <input type="text" class="text" th:classappend="large"/><br/>
```

- 렌더링 되고 난 후

```html
<h1>속성 추가</h1>
  - th:attrappend = <input type="text" class="text large"/><br/>
  - th:attrappend = <input type="text" class="large text"/><br/>
  - th:classappend = <input type="text" class="text large"/><br/>
```

결과를 보면, `attrappend`는 class뒤에 붙고 `attrprepend` class 앞에 붙는다. 그리고    `classappend`는 앞에 붙는다는 걸 알 수 있다.

편의 기능 : 보통 `classappend` 를 많이 쓴다.

- 속성 추가
  - `th:attrappend` : 속성 값의 뒤에 값을 추가한다.
  - `th:attrprepend` : 속성 값의 앞에 값을 추가한다.
  - `th:classappend` : class 속성에 자연스럽게 추가한다.

### ✅checked 처리

HTML에서는 checked 속성이 있으면 checked가 처리되어 나온다.

```html
- HTML checked <input type="checkbox" name="active" checked="false" />
```

<img width="688" alt="Untitled 8" src="https://user-images.githubusercontent.com/56623911/226534533-a722abd0-8908-46da-86d8-f7f51bcd5a83.png">

HTML에서 `checked` 속성은 `checked` 속성의 값과 상관없이 `checked` 라는 속성만 있어도 체크가 된다.

이런 부분이 `true`, `false` 값을 주로 사용하는 개발자 입장에서는 불편하다.

타임리프의 `th:checked` 는 값이 `false`인 경우 `checked` 속성 자체를 제거한다.

- 렌더링 전 타임리프 소스코드

```html
- check o <input type="checkbox" name="active" th:checked="true" /> <br/>
- check x <input type="checkbox" name="active" th:checked="false" /> <br/>
- checked=false <input type="checkbox" name="active" th:checked="false" /> <br/>
```

- 타임리프 렌더링 후 (페이지 소스 보기)

```html
- check o <input type="checkbox" name="active" checked="checked" /> <br/>
- check x <input type="checkbox" name="active" /> <br/>
- checked=false <input type="checkbox" name="active" /> <br/>
```

<img width="686" alt="Untitled 9" src="https://user-images.githubusercontent.com/56623911/226534537-01e33d4d-730a-4825-95f6-d54664287dd0.png">

---

## ➡️반복

타임리프에서 반복은 `th:each` 를 사용한다. 추가로 반복에서 사용할 수 있는 여러 상태 값을 지원한다.

### ✅기본 반복기능

- 렌더링 전 타임리프 소스코드

```html
<h1>기본 테이블</h1>
<table border="1">
   <tr>
     <th>username</th>
     <th>age</th>
   </tr>

   <tr th:each="user : ${users}">
     <td th:text="${user.username}">username</td>
     <td th:text="${user.age}">0</td>
   </tr>
</table>
```

- 렌더링 된 후 페이지 소스

```html
<h1>기본 테이블</h1>
  <table border="1">
    <tr>
      <th>username</th>
      <th>age</th>
    </tr>

    <tr>
      <td>userA</td>
      <td>10</td>
    </tr>

    <tr>
      <td>userB</td>
      <td>20</td>
    </tr>

    <tr>
      <td>userC</td>
      <td>30</td>
    </tr>
  </table>
```

<img width="907" alt="Untitled 10" src="https://user-images.githubusercontent.com/56623911/226534538-51d36207-a453-43e4-b1aa-dc4944f1e0d2.png">

### ✅반복 상태 유지

- 렌더링 전 타임리프 소스코드

```html
<h1>반복 상태 유지</h1>

  <table border="1">
    <tr>
      <th>count</th>
      <th>username</th>
      <th>age</th>
      <th>etc</th>
    </tr>

  <tr th:each="user, userStat : ${users}">
    <td th:text="${userStat.count}">username</td>
    <td th:text="${user.username}">username</td>
    <td th:text="${user.age}">0</td>
    <td>
      index = <span th:text="${userStat.index}"></span>
      count = <span th:text="${userStat.count}"></span>
      size = <span th:text="${userStat.size}"></span>
      even? = <span th:text="${userStat.even}"></span>
      odd? = <span th:text="${userStat.odd}"></span>
      first? = <span th:text="${userStat.first}"></span>
      last? = <span th:text="${userStat.last}"></span>
      current = <span th:text="${userStat.current}"></span>
    </td>
  </tr>
</table>
```

위 코드에서 반복 상태를 유지할 수 있게 해주는 코드

`<tr *th:each*="user, userStat : ${users}">`

반복의 두 번째 파라미터를 설정해서 반복의 상태를 확인 할 수 있다.

두 번째 파라미터는 생략 가능한데, 생략하면 지정한 변수명(`user`) + `Stat`가 된다.

여기서는 `user` + `Stat` = `userStat`이므로 생략 가능하다.

- 렌더링 된 후 페이지 소스

```html
<h1>반복 상태 유지</h1>

  <table border="1">
    <tr>
      <th>count</th>
      <th>username</th>
      <th>age</th>
      <th>etc</th>
    </tr>

  <tr>
    <td>1</td>
    <td>userA</td>
    <td>10</td>
    <td>
      index = <span>0</span>
      count = <span>1</span>
      size = <span>3</span>
      even? = <span>false</span>
      odd? = <span>true</span>
      first? = <span>true</span>
      last? = <span>false</span>
      current = <span>BasicController.User(username=userA, age=10)</span>
    </td>
  </tr>

  <tr>
    <td>2</td>
    <td>userB</td>
    <td>20</td>
    <td>
      index = <span>1</span>
      count = <span>2</span>
      size = <span>3</span>
      even? = <span>true</span>
      odd? = <span>false</span>
      first? = <span>false</span>
      last? = <span>false</span>
      current = <span>BasicController.User(username=userB, age=20)</span>
    </td>
  </tr>

  <tr>
    <td>3</td>
    <td>userC</td>
    <td>30</td>
    <td>
      index = <span>2</span>
      count = <span>3</span>
      size = <span>3</span>
      even? = <span>false</span>
      odd? = <span>true</span>
      first? = <span>false</span>
      last? = <span>true</span>
      current = <span>BasicController.User(username=userC, age=30)</span>
    </td>
  </tr>
</table>
```

- 반복상태 유지 기능
  - `index` : 0부터 시작하는 값
  - `count` : 1부터 시작하는 값
  - `size` : 전체 사이즈
  - `even`, `odd` : 홀수, 짝수 여부(boolean)
  - `first`, `last` : 처음, 마지막 여부(boolean)
  - `current` : 현재 객체

---

## ➡️조건부 평가

`if`, `unless`(if의 반대)

- 렌더링 전 타임리프 소스코드

```html
<h1>if, unless</h1>
  <table border="1">
    <tr>
      <th>count</th>
      <th>username</th>
      <th>age</th>
    </tr>

    <tr th:each="user, userStat : ${users}">
      <td th:text="${userStat.count}">1</td>
      <td th:text="${user.username}">username</td>

      <td>
        <span th:text="${user.age}">0</span>
        <span th:text="'미성년자'" th:if="${user.age lt 20}"></span>
        <span th:text="'미성년자'" th:unless="${user.age ge 20}"></span>
      </td>
    </tr>

  </table>
```

⚠️주의 - ge >=의 not은  >이다.

- 렌더링 된 후 페이지 소스

```html
<h1>if, unless</h1>
  <table border="1">
    <tr>
      <th>count</th>
      <th>username</th>
      <th>age</th>
    </tr>

    <tr>
      <td>1</td>
      <td>userA</td>

      <td>
        <span>10</span>
        <span>미성년자</span>
        <span>미성년자</span>
      </td>
    </tr>

    <tr>
      <td>2</td>
      <td>userB</td>

      <td>
        <span>20</span>


      </td>
    </tr>

    <tr>
      <td>3</td>
      <td>userC</td>

      <td>
        <span>30</span>


      </td>
    </tr>

  </table>
```

### ✅if, unless

타임리프는 해당 조건이 맞지 않으면 태그 자체를 렌더링하지 않는다.

만약 다음 조건이 `false` 인 경우 <span> … <span> 부분 자체가 렌더링 되지 않고 사라진다.

`<span th:text="'미성년자'" th:if="${user.age lt 20}"></span>`

### ✅switch

`*` 은 만족하는 조건이 없을 때 사용하는 디폴트이다.

---

## ➡️주석

- 렌더링 전 타임리프 소스코드

```html
<body>
  <h1>예시</h1>
  <span th:text="${data}">html data</span>

  <h1>1. 표준 HTML 주석</h1>
  <!--
  <span th:text="${data}">html data</span>
  -->

  <h1>2. 타임리프 파서 주석 </h1>
  <!--/* [[${data]] */-->

  <!--/*-->
  <span th:text="${data}">html data</span>
  <!--*/-->

  <h1>3. 타임리프 프로토타입 주석</h1>
  <!--/*/
  <span th:text="${data}">html data</span>
  /*/-->

</body>
```

- 렌더링 된 후 페이지 소스

```html
<body>
  <h1>예시</h1>
  <span>Spring!</span>

  <h1>1. 표준 HTML 주석</h1>
  <!--
  <span th:text="${data}">html data</span>
  -->

  <h1>2. 타임리프 파서 주석 </h1>




  <h1>3. 타임리프 프로토타입 주석</h1>

  <span>Spring!</span>


</body>
```

### 1️⃣ 표준 HTML 주석

- 자바스크립트의 표준 HTML 주석은 타임리프가 렌더링 하지 않고, 그대로 남겨둔다.

### 2️⃣ 타임리프 파서 주석

- 타임리프 파서 주석은 타임리프의 진짜 주석이다. 렌더링에서 주석 부분을 제거한다.

### 3️⃣ 타임리프 프로토타입 주석

타임리프 프로토타입은 약간 특이점이 있다. HTML 주석에 약간의 구문을 더했다.

HTML 파일을 웹 브라우저에서 그대로 열어보면 HTML 주석이기 때문에 이 부분이 웹 브라우저가 렌더링하지 않는다.

타임리프 렌더링을 거치면 이 부분이 정상 렌더링 된다.

다시말하면 HTML 파일을 그대로 열어보면 주석처리가 되지만, 타임리프를 렌더링한 경우에만 보이는 기능이다.

---

## ➡️블록

`<th:block>` 은 HTML 태그가 아닌 타임리프의 유일한 자체 태그다.

- 렌더링 전 타임리프 소스코드

```html
<body>
<th:block th:each="user : ${users}">
  <div>
    사용자 이름1 <span th:text="${user.username}"></span>
    사용자 나이1 <span th:text="${user.age}"></span>
  </div>

  <div>
    요약 <span th:text="${user.username} + ' / ' + ${user.age}"></span>
  </div>
</th:block>
</body>
```

- 렌더링 된 후 페이지 소스

```html
<body>
  <div>
    사용자 이름1 <span>userA</span>
    사용자 나이1 <span>10</span>
  </div>

  <div>
    요약 <span>userA / 10</span>
  </div>

  <div>
    사용자 이름1 <span>userB</span>
    사용자 나이1 <span>20</span>
  </div>

  <div>
    요약 <span>userB / 20</span>
  </div>

  <div>
    사용자 이름1 <span>userC</span>
    사용자 나이1 <span>30</span>
  </div>

  <div>
    요약 <span>userC / 30</span>
  </div>

</body>
```



타임리프의 특성상 HTML 태그안에 속성으로 기능을 정의해서 사용하는데, 위 예처럼 이렇게 사용하기 애매한 경우에 사용하면 된다.

`<th:block>` 은 렌더링시 제거된다.

---

## ➡️자바스크립트 인라인

### ✅자바스크립트 인라인 사용 전

텍스트 렌더링

- 렌더링 전 타임리프 소스코드

```html
<script>
  var username = [[${user.username}]];
  var age = [[${user.age}]];

  //자바스크립트 내추럴 템플릿
  var username2 = /*[[${user.username}]]*/ "test username";

  // 객체
  var user =[[${user}]];
</script>
```

- 렌더링 된 후 페이지 소스

```html
<script>

  var username = userA;
  var age = 10;

  //자바스크립트 내추럴 템플릿
  var username2 = /*userA*/ "test username";

  // 객체
  var user =BasicController.User(username=userA, age=10);
</script>
```

아래와 같이 오류가 뜬다. 자바스크립트가 깨진 것..

<img width="503" alt="Untitled 11" src="https://user-images.githubusercontent.com/56623911/226534542-f0f07ba6-5b6f-4d4b-9b27-d1337abf9347.png">

- `“` 를 사용하면 에러는 안뜬다.

```html
var username = "[[${user.username}]]";
```

### ✅ 자바스크립트 인라인 사용 후

- 예제) 자바스크립트 인라인 사용 후

```html

<script th:inline="javascript">
  var username = [[${user.username}]];
  var age = [[${user.age}]];

  //자바스크립트 내추럴 템플릿
  var username2 = /*[[${user.username]]*/ "test username";

  //객체
  var user = [[$[user]]];

</script>
```

- 렌더링 된 후 페이지 소스

```html
<script>
  var username = "userA";
  var age = 10;

  //자바스크립트 내추럴 템플릿
  var username2 = "userA";

  //객체
  var user = {"username":"userA","age":10};

</script>
```

### ✅텍스트 렌더링

- `var username  = [[${user.username}]]`
  - 인라인 사용 전 : `var username = userA;`
  - 인라인 사용 후 :`var username = "userA”;`
- 인라인 사용 전 렌더링 결과를 보면 `userA` 라는 변수 이름이 그대로 남아있다. 타임리프 입장에서는 정확하게 렌더링 한 것이지만 아마 개발자가 기대한 것은 다음과 같은 `“userA”`라는 문자일 것이다. 결과적으로 `userA` 가 변수명으로 사용되어서 자바스크립트 오류가 발생한다. 다음으로 나오는 숫자 age의 경우에는 `“` 가 필요 없기 때문에 정상 렌더링 된다.
- 인라인 사용 후 렌더링 결과를 보면 타입인 경우 `“` 를 포함해준다.
- 자바스크립트에서 문제가 될 수 있는 문자가 포함되어 있으면 이스케이프 처리도 해준다.

예) `”` → `\"`

### ✅자바스크립트 내추럴 템플릿

타임리프 HTML 파일을 직접 열어도 동작하는 내추럴 템플릿 기능을 제공한다. 자바스크립트 인라인 기능을 사용하면 주석을 활용해서 이 기능을 사용할 수 있다.

- `var username2 = /*[[${user.username]]*/ "test username";`
  - 인라인 사용 전 : `var username2 = /*userA*/ “test username”;`
  - 인라인 사용 후 : `var username2 = "userA";`


### ✅ 객체

타임리프의 자바스크립트 인라인 기능을 사용하면 객체를 JSON으로 자동으로 변환해준다.

- `var user = [[$[user]]];`
  - 인라인 사용 전 : `var user = BasicController.User(username=userA, age=10);`
  - 인라인 사용 후 :  `var user = {"username":"userA", "age": 10};`

- 인라인 사용 전은 객체의 toString()이 호출된 값이다.
- 인라인 사용 후는 객체를 JSON으로 변환해준다.

### ❗️자바스크립트 인라인 each

자바스크립트 인라인은 each를 지원한다.

- 자바스크립트 인라인 each

```html
<script th:inline="javascript">
  [# th:each="user, stat : ${users}"]
  var user[[${stat.count}]] = [[${user}]];
  [/]

</script>
```

- 렌더링 된 후 페이지 소스

```html
<script>
  var user1 = {"username":"userA","age":10};
  var user2 = {"username":"userB","age":20};
  var user3 = {"username":"userC","age":30};
</script>
```

---

## 템플릿 조각

웹페이지를 개발할 때 공통 영역이 많이 있다. 예를 들면 상단 영역이나 하단 영역, 좌측 카테고리 등등 여러 페이지에서 함께 사용하는 영역들이 있다. 이런 부분을 코드를 복사해서 사용한다면 변경 시 여러 페이지를 다 수정해야 하므로 상당히 비효율적이다. 타임리프는 이런 문제를 해결하기 위해 **`템플릿 조각`**과 **`레이아웃 기능`**을 지원한다.

`emplate/fragment/footer :: copy`- `template/fragment/footer.html` 템플릿에 있는 `th:fragment="copy"` 라는 부분을 템플릿 조각으로 가져와서 사용한다는 의미이다.

### ✅insert

- 렌더링 전 페이지 소스

```html
<h1>부분 포함</h1>
  <h2>부분 포함 insert</h2>
<div th:insert="~{template/fragment/footer :: copy}"></div>
```

- 렌더링 후 페이지 소스

```html
<h2>부분 포함 insert</h2>
<div><footer>
  푸터 자리입니다.
</footer></div>
```

`th:inert` 를 사용하면 현재 태그 (`<div>`)내부에 추가한다.

### ✅replace

- 렌더링 전 페이지 소스

```html
<h2>부분 포함 replace</h2>
<footer>
  푸터 자리입니다.
</footer>
```

- 렌더링 후 페이지 소스

```html
<h2>부분 포함 replace</h2>
<div th:replace="~{template/fragment/footer :: copy}"></div>
```

`th:replace` 를 사용하면 현재 태그(`<div>`)를 대체한다.

### ✅부분 포함 단순 표현식

`<div *th:replace*="template/fragment/footer :: copy"></div>`

- `~{...}` 를 사용하는 것이 원칙이지만 템플릿 조각을 사용하는 코드가 단순하면 이 부분을 생략할 수 있다.

### ✅파라미터 사용

`<div *th:replace*="~{template/fragment/footer :: copyParam ('데이터1', '데이터2')}"></div>`

- 렌더링 전 페이지소스

```html
<footer th:fragment="copyParam (param1, param2)">
  <p>파라미터 자리 입니다.</p>
  <p th:text="${param1}"></p>
  <p th:text="${param2}"></p>
</footer>
```

- 렌더링 후 페이지 소스

```html
<h1>파라미터 사용</h1>
<footer>
  <p>파라미터 자리 입니다.</p>
  <p>데이터1</p>
  <p>데이터2</p>
</foote
```

---

## ➡️템플릿 레이아웃

일부 코드 조각을 가지고 와서 사용하는 걸 확장해서 코드 조각을 레이아웃에 넘겨서 사용하는 방법에 대해서 알아보자.

예를 들어서 <head> 에 공통으로 사용하는 css, javascript 같은 정보들이 있는데, 이러한 공통 정보들을 한 곳에 모아두고, 공통으로 사용하지만, 각 페이지마다 필요한 정보를 더 추가해서 사용하고 싶다면 다음과 같이 사용하면 된다.

- base

```html
<!DOCTYPE html>
<html lang="en">
<head th:fragment="common_header(title, links)">
    <meta charset="UTF-8">
    <title th:replace="${title}">레이아웃 타이틀</title>

  <!-- 공통 -->
  <link rel="stylesheet" type="text/css" media="all" th:href="@{/css/awesomeapp.css}">
  <link ref="shortcut icon" th:href="@{/images/favicon.ico}">
  <script type="text/javascript" th:src="@{/sh/scripts/codebase.js}"></script>

  <!-- 추가 -->
  <th:block th:replace="${links}"/>

</head>
<body>

</body>
</html>
```

- layoutMain

```html
<!DOCTYPE html>
<html lang="en">
<head th:replace="template/layout/base :: common_header(~{::title},~{::link})">
    <meta charset="UTF-8">
    <title>메인 타이틀</title>
    <link rel="stylesheet" th:href="@{/css/bootstrap.min.css}">
    <link rel="stylesheet" th:href="@{/themes/smoothness/jquery-ui.css}">
</head>
<body>

</body>
</html>
```

- 렌더링 후 페이지소스

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>메인 타이틀</title>

  <!-- 공통 -->
  <link rel="stylesheet" type="text/css" media="all" href="/css/awesomeapp.css">
  <link ref="shortcut icon" href="/images/favicon.ico">
  <script type="text/javascript" src="/sh/scripts/codebase.js"></script>

  <!-- 추가 -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/themes/smoothness/jquery-ui.css">

</head>
<body>

</body>
</html>
```

- `Common_header(~{::title}, ~{::link})` 이 부분이 핵심이다.
  - `::title` 은 현재 페이지의 title 태그들을 전달한다.
  - `::link` 은 현재 페이지의 link 태그들을 전달한다.

### ❗️결과

- 메인 타이틀이 전달한 부분으로 교체되었다.
- 공통 부분은 그대로 유지되고, 추가 부분에 전달한 `<link>` 들이 포함된 것을 확인할 수 있다.

---

## ➡️템플릿 레이아웃 2

위에서는 `<head>` 정도에만 적용했다. 이번에는 `<html>` 전체에 적용할 수도 있다.

### 템플릿 레이아웃 확장

- layoutFile

```html
<!DOCTYPE html>
<html th:fragment="layout (title, content)">
<head>
    <meta charset="UTF-8">
    <title th:replace="${title}">레이아웃 타이틀</title>
</head>
<body>
<h1>레이아웃 H1</h1>
<div th:replace="${content}">
  <p>레이아웃 컨텐츠</p>
</div>
<footer>
  레이아웃 푸터
</footer>
</body>
</html>
```

- layoutExtendMain

```html
<!DOCTYPE html>
<html th:replace="~{template/layoutExtend/layoutFile :: layout(~{::title}, ~{::section})}">
<head>
    <meta charset="UTF-8">
    <title>메인 페이지 타이틀</title>
</head>
<body>
<section>
    <p>메인 페이지 컨텐츠</p>
  <div>메인 페이지 포함 내용</div>
</section>

</body>
</html>
```

- 렌더링 후 페이지소스

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>메인 페이지 타이틀</title>
</head>
<body>
<h1>레이아웃 H1</h1>
<section>
    <p>메인 페이지 컨텐츠</p>
  <div>메인 페이지 포함 내용</div>
</section>
<footer>
  레이아웃 푸터
</footer>
</body>
</html>
```

`layoutFile.html` 을 보면 기본 레이아웃을 가지고 있는데, `<html>` 에 `th:fragment` 속성이 정의되어 있다. 이 레이아웃 파일을 기본으로 하고 여기에 필요한 내용을 전달해서 부분부분 변경하는 것을 이해하면됨

`layoutExtendMain.html` 는 현재 페이지인데, `<html>` 자체를 `th:replace` 를 사용해서 변경하는 것을 확인할 수 있다.

따라서 `layoutFile.html` 에 필요한 내용을 전달하면서 `<html>` 자체를 `layoutFile.html` 로 변경한다.

---

## 📎참고

- ****[스프링 MVC 2편 - 백엔드 웹 개발 활용 기술](https://www.inflearn.com/course/스프링-mvc-2/dashboard)****
- [thymeleaf.org](https://www.thymeleaf.org)
- [thymeleaf 기본기능](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)

<!-- outline-end -->
