---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: Java - Interface, 추상클래스, enum

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java]
# thumbnail image for post
img: ":java.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-10-26 23:30:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-10-26 23:30:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->

# 제 13장 인터페이스와 추상클래스, enum

### 인터페이스와 abstract 클래스를 사용하는 이유

- 설계시 선언해 두면 개발할 때 기능을 구현하는 데에만 집중할 수 있다.
- 개발자의 역량에 따른 메소드의 이름과 매개 변수 선언의 격치를 줄일 수 있다.
- 공통적인 인터페이스와 abstract 클래스를 선언해 놓으면, 선언과 구현을 구분할 수 있다.

### 인터페이스 실습

```java
public interface MemberManager {
    public boolean addMember(MemberDTO member);
    public boolean removeMember(String name, String phone);
    public boolean updateMember(MemberDTO member);
}
```

```java
public class MemberMangerImpl implements MemberManager{

}
```



위의 내용을 컴파일해보면 컴파일이 안된다. 그리고 에러가 뜬다.

```java
에러 메시지 : MemberMangerImpl is not abstract and does not override abstract method updateMember(MemberDTO) in MemberManger
```

해석하면 “MemberMangerImpl 클래스는 abstract 클래스도 아니고, MemberManger에 정의되어 있는 updateMember()라는 abstrace 메소드도 구현하지 않았다.” 라고 한다.

해결책 : 인터페이스를 구현할 경우(implements)에는 반드시 인터페이스에 정의된 메소드들의 몸통을 만들어 주어야만 한다. 즉, 메소드들을 구현해야한다.

```java
public class MemberMangerImpl implements MemberManager{

    @Override
    public boolean addMember(MemberDTO member) {
        return false;
    }

    @Override
    public boolean removeMember(String name, String phone) {
        return false;
    }

    @Override
    public boolean updateMember(MemberDTO member) {
        return false;
    }
}
```

메소드들을 구현해야지 컴파일 에러가 뜨지않는다.

---

예제)

```java
public class InterfaceExample {
    public static void main(String[] args) {
        MemberManager member = new MemberManager();
    }
}
```

위와 같은 코드를 작성시 컴파일 에러가 뜬다.. 왜일까 ?

```java
에러 메시지 : MemberManager is abstract; cannot be instantiated
```

해석하면 MemberManager가 abstract이기 때문에 초기화가 되지 않는다는 메시지가 출력된다.

```java
public class InterfaceExample {
    public static void main(String[] args) {
        MemberManager member = new MemberManagerImpl();

    }
}
```

위 코드는 `member`의 타입은 `MebmerManager`이다. 그리고, `MemberManagerImpl` 클래스에는 인터페이스에 선언되어 있는 모든 메소드들이 구현되어 있다. 따라서 실제 `member` 의 타입은 `MemberManager` 가 되기 때문에, member에 선언된 메소드들을 실행하면 `MemberManagerImpl` 에 있는 메소드들이 실행된다.

## 일부 완성되어 있는 abstract클래스

`abstract` 클래스는 자바에서 마음대로 초기화하고 실행할 수 있도록 되어있다.

- abstract 클래스 형식

```java
접근제어자 abstract class 클래스이름{
    접근제어자 abstract boolean 메소드이름();
}
```

```java
public abstract class MemberManagerAbstract {
    public abstract boolean addMember(MemberDTO member);
    public abstract boolean removeMember(String name, String phone);
    public abstract boolean updateMember(MemberDTO member);

    public void printLog(String data) {
        System.out.println("Data =" + data);
    }

}
```

<!-- outline-end -->
