---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: 데이터베이스 - 5주차 정리

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java]
# thumbnail image for post
img: ":java.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2023-12-11 22:30:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2023-06-01 23:15:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# 데이터베이스 5주차 정리

# 5주차

## DB 세션에 대해서 설명해주세요.

DB세션은 데이터베이스와 사용자 간의 연결을 의미한다.

사용자가 데이터베이스에 접속하여 SQL명령을 실행하는 동안에는 세션이 유지된다. 세션이 종료되면 사용자와 데이터베이스 간의 열결이 끊어진다.

- 세션 구성 요소
  - 접속 정보 : 사용자 ID, 비밀번호, 데이터베이스 이름, 접속 IP 주소 등
  - 연결 정보 : 데이터베이스 서버의 주소, 포트번호, 사용 프로토콜 등
  - 세션 상태 정보 : 사용자의 권한, 현재 작업 중인 트랜잭션 정보 등


세션은 사용자의 데이터베이스 사용에 필요한 모든 정보를 포함하고 있다. 따라서 세션을 통해 사용자는 데이터베이스에 저장된 데이터를 조회, 추가, 수정, 삭제를 할 수 있다.

## Commit에 대해서 설명해주세요.

Commit 문은 트랜잭션의 종료를 알리고 트랜잭션 내의 모든 변경 사항을 데이터베이스에 영구적으로 저장하는 명령이다.

- Commit의 역할
  - 트랜잭션 내의 모든 변경 사항을 데이터베이스에 영구적으로 저장한다.
  - 트랜잭션을 종료한다.

## Rollback에 대해서 설명해주세요.

DB에서 Rollback은 트랜잭션을 실패로 처리하고, 트랜잭션 내의 모든 변경 사항을 취소하는 명령이다.

- Rollback 역할
  - 트랜잭션 내의 모든 변경 사항을 취소한다.
  - 트랜잭션을 실패로 처리한다.

## Auto Commit 설정에 대해서 설명해주세요.

Auto Commit은 트랜잭션 시작할 때 모든 변경 사항을 데이터베이스에 영구적으로 저장하는 설정이다.

- 활성화
  - Auto Commit이 활성화된 상태에서는 트랜잭션을 시작하지 않고도 모든 SQL 명령을 실행할 때마다 변경 사항이 데이터베이스에 영구적으로 저장된다.
- 비활성화
  - Auto Commit 비활성화된 상태에서는 트랜잭션을 시작해야만 변경 사항이 데이터베이스에 영구적으로 저장된다.

- Auto Commit 설정

```sql
SET AUTOCOMMIT = [ON | OFF]
```

## 트랜잭션에 대해 설명해주세요.

트랜잭션은 데이터베이스에 일련의 작업을 수행하는 단위이다.

보통 단일 SQL문을 사용하여 다루기도 하지만 여러 개의 SQL문을 순차적으로 수행하여 다루기도한다.

트랜잭션은 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 갖는다.

## 트랜잭션의 성질 ACID에 대해서 설명해주세요.

- 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야한다. (All or Nothing)
- 일관성(Consistency) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
- 고립성(Isolation) : 수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.
- 지속성(Durability) 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야한다. 저장된 데이터베이스는 저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 한다.

## 트랜잭션 격리 수준이 뭘까요?

트랜잭션 격리 수준은 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

격리 수준은 크게 4가지로 나뉜다.

1. READ UNCOMMITTED(DIRTY READ라고도 한다.)
2. READ COMMITTED
3. REPEATABLE READ
4. SERIALIZABLE

## 트랜잭션 격리 수준 READ UNCOMMITTIED에 대해서 설명해주세요.

트랜잭션 격리 수준 READ UNCOMMITTED는 가장 낮은 격리 수준이며, 이 격리 수준에서는 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있다.

<img width="1007" alt="Untitled" src="https://github.com/YuDeokRin/JavaCordingTest/assets/56623911/d2e6ae63-79e4-44b6-b26e-3dece38be3a5">

## 트랜잭션 격리 수준 READ COMMITTED에 대해서 설명해주세요.

READ COMMITTED는 READ UNCOMMITTED 격리 수준보다 높은 격리 수준을 갖고 있으며, 이 격리 수준에서는 트랜잭션이 커밋된 데이터만 읽을 수 있다.

- READ COMMITTED 격리 수준에서는 Dirty read가 발생하지 않습니다. 그 이유는 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문이다.

- 오라클 DBMS에서 기본으로 사용되는 격리 수준이다.

## 트랜잭션 격리 수준 REPEATABLE READ에 대해서 설명해주세요.

REPEATABLE READ는 트랜잭션이 동일한 쿼리를 실행할 때마다 동일한 결과를 반환한다.

- MySQL의 InnoDB 스토리 엔진에서 기본으로 사용되는 격리수준이다.
- 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다.

## 트랜잭션 격리 수준 SERIALIZABLE에 대해서 설명해주세요.

SERIALIZABLE 트랜잭션 격리 수준은 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션은 절대 접근할 수 없다는 것이다.

## DB 동시성 제어에 대해서 설명해주세요.

트랜잭션이 동시에 실행될 때 데이터베이스의 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능이다.

## 갱신 손실 문제에 대해 설명해주세요.

동시성 제어를 하지 않는 트랜잭션들이 발생시키는 문제로, 한 트랜잭션의 갱신이 다른 트랜잭션에 의하여 분실되는 현상이다.

## DB 락에 대해서 설명해주세요.

트랜잭션이 데이터를 읽거나 변경할 때 데이터에 표시하는 잠금 장치이다.

DB락은 갱신손실 문제를 해결하기위해서 나타났다. 상대방의 트랜잭션이 데이터를 사용하는지 알 수 있는 규칙이 필요한데, 데이터를 읽거나 변경할 때 데이터에 표시하는 잠금 장치이다.

- 락의 유형
  - 공유락 : 읽기를 할 때 사용하는 잠금 장치이다.
  - 배타락 : 쓰기를 할 때 사용하는 잠금 장치이다.


## DB 데드락에 대해서 설명해주세요.

두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하여 무한 대기 상태에 빠지는 현상을 말한다.

## DB 회복에 대해서 설명해주세요.

DB회복은 데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능이다.

- 데이터베이스에서 발생할 수 있는 장애 유형
  - 시스템 충돌
  - 미디어 장애
  - 응용 소프트웨어 오류
  - 자연재해
  - 부주의 혹은 태업

## REDO, UNDO에 대해서 설명해주세요.

- 재실행(REDO)는 로그 파일에 기록된 로그를 이용하여 트랜잭션이 수행한 결과를 다시 반영하는 연산이다.
- 취소(UNDO)는 로그 파일에 기록된 로그를 이용하여 트랜잭션이 수행한 결과를 취소하는 연산이다.

```
Tip. 회복을 위한 로그 기록 방법

즉시갱신 : 트랜잭션은 '갱신데이터 -> 로그, 버퍼 -> 데이터베이스' 작업이 부분완료 전에 동시에 진행될 수 있으며 REDO, UNDO 연산을 이용하여 복구한다.
지연갱신 : 트랜잭션은 '갱신데이터 -> 로드'가 끝난 후 부분완료를 하고 '버퍼 -> 데이터베이스' 작업은 부분완료 후에 진행한다. REDO 연산을 이용하여 복구한다.

```

## 체크포인트 회복 기법에 대해서 설명해주세요.

데이터베이스와 트랜잭션 로그 파일을 동기화한 후, 동기화한 시점을 로그 파일에 기록해 두는데 이를 체크포인트라고 한다.

- 체크포인트의 역할
  - 주기억장치의 로그 레코드를 모두 하드디스크의 로그파일에 저장한다.
  - 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장한다.(즉시갱신의 경우).
  - 체크포인트를 로그 파일에 표시한다.

## MySQL InnoDB의 기본 트랜잭션 고립 수준은 뭘까요?

MySQL InnoDB의 기본 트랜잭션 고립 수준은 `REPEATABLE READ`이다.

InnoDB스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 UNDO공간에 백업해두고 실제 레코드 값을 변경한다.

이러한 변경 방식을 MVCC(Multi Version Concurrency Control)라고한다.

REPEATABLE READ는 MVCC를 위해 UNDO 영억에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.



<!-- outline-end -->
