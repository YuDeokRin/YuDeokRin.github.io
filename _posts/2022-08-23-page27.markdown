---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title:Spring Security(CSRF-Synchronizer Token Pattern)

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Security, Network, Web]
# thumbnail image for post
img: ":CSRFToken.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-08-23 23:55:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-08-23 23:55:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# CSRF 토큰

CSRF**(Cross-site request forgery)**

글쓴이는 CSRF를 spring security를 사용하면서  알게되었기 때문에  spring 환경 토대로 설명드리겠습니다.

# CSRF 공격이란?

CSRF의 공격 상황을 예시로 확인해보자.

### 상황 1

- 은행 웹사이트에서 현재 로그인한 사용자의 돈을 다른 은행 계좌로 이체할 수 있는 양식을 제공한다고 가정해보자. 아래의 코드는 은행 웹사이트  전송 양식

```html
<form method="post"
	action="/transfer">
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="text"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
```

- HTTP 요청

```html
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
```

### 상황 2

은행 웹사이트에 인증한 다음 로그아웃을 하지않고 악의적인 웹사이트를 방문한다고 가정하자.

아래의 코드는 악의적인 웹사이트의 전송 방식의 양식

```html
<form method="post"
	action="https://bank.example.com/transfer">
<input type="hidden"
	name="amount"
	value="100.00"/>
<input type="hidden"
	name="routingNumber"
	value="evilsRoutingNumber"/>
<input type="hidden"
	name="account"
	value="evilsAccountNumber"/>
<input type="submit"
	value="Win Money!"/>
</form>
```

도박 사이트에서 돈을 따기 위해서 submit 버튼을 눌렀다.  그 과정에서 의도치 않게 100달러를 도박 사이트 사용자에게 전송했습니다.

이 상황에서는 악의적인 웹사이트가 나의 쿠키를  볼 수 없지만 나의 은행과 관련된 쿠키가 요청과 함께 계속 전송되기 때문에 문제가 발생한다.

그렇다면 이 공격으로부터 안전하려면 어떻게해야될까 ?

<aside>
💡 해결책

</aside>

CSRF 공격이 가능하게 된 이유는 피해자 웹사이트의 HTTP 요청과 공격자 웹사이트의 요청이 정확히 동일하기 때문이다.

CSRF공격으로부터 보호하려면 두 요청을 구별할 수 있도록 악의적인 사이트에서 제공할 수 없는 요청이 있는지 확인해야한다.

Spring은 CSRF 공격으로부터 보호하는 두 가지 메커니즘을 제공한다.

### 1. 동기화 장치 토큰 패턴(**Synchronizer Token Pattern)**

### 2. 세션 쿠키에 SameSite 속성 지정

글쓴이는 토큰 패턴이 spring security에서 사용되는 것을 알게되어서 관심이 더욱 갔다.

회원가입 form에서 요청을 보내면 Security가 CSRF토큰을 붙여서 응답을 해준다.

![Untitled](https://user-images.githubusercontent.com/56623911/186190634-9ba79d9f-5d96-47af-96ef-e9ad30f3a71f.png)


`Synchronizer Token Patten`은 CSRF 공격으로부터 보호를 가장 많이 사용하는 방법이다. 이 방법은
<!-- outline-end -->
