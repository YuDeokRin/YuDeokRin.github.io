---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: UserModel 만들기

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java, Algorithm]
# thumbnail image for post
img: ":UserModel.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-09-18 22:55:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-09-18 22:55:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# User 모델 만들기

username, password, email, name의 데이터를 받을 수 있는 DTO(Data Transfer Object)를 만들어보자.

```java
└─📁COME.COS.photogram
   │
   └─📁web
       │
       └─ 📁dto
            │
            └─📁auth
            │
            └─ 📦 SignupDto.java
```

### 생성

package : dto, auth

class : SignupDto.java(Requset DTO)

dto 요청, 응답이 있다.

- 요청 (데이터베이스에게)
- 응답

```java
@Date
public class SignupDto{
	private String username;
	private String password;
	private String email;
	private String name;
}
```

**@Data :  Getter와 Setter를 만들어주는 애너테이션 (Lombok에 있는 애너테이션)**

- **AuthController에 signup(SignupDto signupDto)에 추가**

**`SignupDto signupDto`** 는 form태그에서 입력된 값이 받아온다.

```java
@Controller
public class AuthController {

		@PostMapping("/auth/signup")
		public String signup(SignupDto signupDto){
		return "auth/signup";
		}
}
```

form(태그)으로 데이터가 오면 데이터 형식(Key = value (x-www-form-urlencoded) )

Spring은 기본적으로 `x-www-form-urlencoded` 방식으로 데이터를 받아준다.

- **로그를 찍어서 데이터를 잘 받았는지 확인해보자 !**

```java
@Controller
public class AuthController {
		private static final logger log = LoggerFactory.getLogger(AuthController.class);

		@PostMapping("/auth/signup")
		public String signup(SignupDto signupDto){
			log.info(signupDto.toString());
			return "auth/signup";
		}
}
```

- 로그를 찍어낸 결과 데이터를 잘 받아온다.

![Untitled](https://user-images.githubusercontent.com/56623911/190906324-015f9511-0a5e-4efd-99b0-8cacdf98baac.png)

자 ! 다음 step 받은 데이터들을 데이터베이스에 insert 해준다.

How ?

우선 모델이 필요 → User 모델

```java
└─📁COME.COS.photogram
   │
   └─📁domain
       │
       └─📁user
			   │
			   └─📦 User.java
```

- 생성

package : domain, user

class : User.java

```java
//JPA : Java Persistence API(자바로 데이터를 영구적으로 저장(DB에)할 수 있는 API를 제공)
@AllArgsConstructor // 전체 생성자
@NoargsConstructor //빈 생성자
@Data // Getter/Setter
@Entity //DB에 테이블을 생성해준다.
public class User{
		private int id;   // Long id

		private String username;
		private String password;

		private String name; // 이름
		private String website;  // 웹사이트
		private String bio; // 자기 소개
		private String email;
		private String phone;
		private String gender;

		private String profileimageUrl; // 훗날 작성자의 사진이될 변수
		private String role; //권한

		//데이터베이스에게 데이터가 언제 들어 왔는지 항상 필요하다.
		private LocalDateTime createDate; // 데이터가 언제 들어왔는지 데이터베이스는 필요하다 !

		@PrePersist // createDate()가 데이터베이스에 insert되기 직전에 PrePersist가 실행
		public void createDate(){
			this.createDate = LocalDateTime.now();
		}
}
```

실제 서비스를 한다면 `Long`으로 하는게 좋긴하다. 하지만 여기선 미니프로젝트이니 `int`로 하겠다.

| 정수형 타입 | 할당되는 메모리의 크기 | 데이터의 표현 범위 |
| --- | --- | --- |
| byte | 1바이트 | -128 ~ 127 |
| short | 2바이트 | -215 ~ (215 - 1) |
|  |  | -32,768 ~ 32,767 |
| int | 4바이트 | -231 ~ (231 - 1) |
|  |  | -2,147,483,648 ~ 2,147,483,647 |
| long | 8바이트 | -263 ~ (263 - 1) |
|  |  | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |

- 데이터베이스에 값을 넣어줄 때, 위에 데이터(username, password, name, website, bio, email, phone, gender)를 넣어주면 createDate()는 자동으로 들어간다.

createDate()는 데이터를 넣은 시간을 나타낸다.

```java
		@PrePersist // createDate()가 데이터베이스에 insert되기 직전에 PrePersist가 실행
		public void createDate(){
			this.createDate = LocalDateTime.now();
		}
```

- @Entity : DB에 테이블을 생성해준다.
- @Data : Getter/Setter 생성
- @NoargsConstructor :빈 생성자
- @AllArgsConstructor :전체 생성자

```java
@AllArgsConstructor // 전체 생성자
@NoargsConstructor //빈 생성자
@Data // Getter/Setter 생성
@Entity //디비에 테이블을 생성해준다.
public class User{
}
```

어플리케이션 실행 ! 하지만 실패 …

**why? Error Primary key가 없어서 오류나는 것이다. →** `Entity에 대한 식별(identifier)이 없다.`

> 오류 메시지 - No identifier specified for entity : com.cos.photogram.domain.user.User
>

```java
@NoargsConstructor //빈 생성자
@Data // Getter/Setter
@Entity //디비에 테이블을 생성해준다.
public class User{

		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY) // 번호 증가 전략이 데이터베이스를 따라간다.
		private int id;   // primary key

		private String username;
		private String password;

		private String name; // 이름
		private String website;  // 웹사이트
		private String bio; // 자기 소개
		private String email;
		private String phone;
		private String gender;

		private String profileimageUrl; // 훗날 작성자의 사진이될 변수
		private String role; //권한

		//데이터베이스에게 데이터가 언제 들어 왔는지 항상 필요하다.
		private LocalDateTime createDate; // 데이터가 언제 들어왔는지 데이터베이스는 필요하다 !

		@PrePersist // createDate()가 데이터베이스에 insert되기 직전에 PrePersist가 실행
		public void createDate(){
			this.createDate = LocalDateTime.now();
		}
}
```

추가

> @GeneratedValue(strategy = GenerationType.IDENTITY)
>

- 번호 증가 전략(`strategy = GenerationType.IDENTITY`)이 데이터베이스를 따라간다.
  - mysql, mariadb- **`Auto Increment`을 쓴다.**
  - Oracle - **`SequenceGenerator`을 쓴다.**

### 데이터베이스에  접속한다.

![Untitled 1](https://user-images.githubusercontent.com/56623911/190906312-7f8c6490-8e14-4b80-b92b-ce4128b6344c.png)

![Untitled 2](https://user-images.githubusercontent.com/56623911/190906317-6d3a0849-e376-4e99-ba6c-b55a8de4db45.png)

이런 식으로 테이블이 만들어진다.   객체를 테이블로 만들어 ?!!!  이게 ORM의 세계 ?!!!

대박..

![tumblr_mijuioESRS1qg6rkio1_500](https://user-images.githubusercontent.com/56623911/190906281-dfb03bd2-cd40-40ee-8f68-42cd5e9ca5f5.gif)

### **application.yml  안에 JPA → ddl-auto의 역할은?**

ddl-auto

- update : 데이터를 insert하고 나서 서버를 다시 실행해도 유지되어 남아있게 해준다.
- create : 데이터를 insert하고 나서 서버를 재실행하면 insert했던 데이터가 다 사라진다.

```yaml
jpa:
open-in-view:true
  hibernate:
ddl-auto: create
naming:
physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
show-sql:true

```

## UserModel 글을 쓴 회고
UserModel을 직접 만들고 JPA를 쓰니깐.. 와 정말 편하다. 점점 툴이 극적인 기능을 갖고 나타날 것같다. 이미 나온 것만 봐도.. 입이 다물어지지 않는다.
대박이다..


<!-- outline-end -->
