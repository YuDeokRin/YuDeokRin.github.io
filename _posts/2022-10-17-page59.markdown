---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: JVM_Stack Frame

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [Java,The Java Manipulation]
# thumbnail image for post
img: ":studyHalle.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-10-17 23:58:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-10-17 23:58:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->

# Stack Frame

## Stack Frame

- Stack Frame이라는 것은 Thread가 수행하고 있는 Application을 Method단위로 기록하는 곳이다.
- Stack Frame은 Method를 실행하면 Class의 메타 정보를 이용하여 적절한 크기로 생성된다.
- Stack Frame의 크기는 Complier 시점에서 이미 결정된다. 그렇기 때문에 가변의 크기가 아니다.

![Untitled](https://user-images.githubusercontent.com/56623911/196210046-a3c129d8-b4e5-4451-af6a-f5f870aa2503.png)

## Local Variable Section

- Local Variable Section은 Method의 Parameter Variable(매개변수)과 Local Variable(지역변수)들을 저장한다.
- Local Variable Section은 배열로 구성되어있으며 인덱스를 통해서 데이터에 접근한다.
- Parameter Variable는 선언된 순서로 인덱스 할당한다.
- Local Variable는 Compiler가 인덱스를 할당한다. 할당 한다는 것은 Local Variable Section에 저장공간을 마련한다는 의미.

```java
public int testMethod(int a,
                     char b,
                     long c,
                    float d,
                   Object e,
                   double f,
                   String g,
                     byte h,
                    short i,
                  boolean j) {
        return 0;
}
```

위의 예제는 `기본타입(Primitive Type)`과 `참조타입(Reference Type)`의 각각 의경우가 `Local Variable Section`에 저장되는 값이 다르다.

어떻게 다를까? 그림을 통해서 알아보자

![Untitled 1](https://user-images.githubusercontent.com/56623911/196209994-41f3502f-3927-4dee-97c9-c537560eceb7.png)

위 그림을 보면 int a는  할당 받아 변수를 저장할 준비가 되어있다. 하지만 `e`, `g`는 `reference`로 할당 받았다.

`Local Variable Section`는 `reference형`으로 저장되는 것을 표현한 것이라고 할 수 있다.

`Local Variable Section`에는 객체의 정보가 직접적으로 들어가있는 것이아니라 Heap의 위치를 말해주는 Reference를 저장한다는 것이다.

실제 객체는 Heap에 저장되는 것이다.

따라서 Integer 형과 int형 중 어떤 것이 성능에서 유리할까 ? 라는 질문이 생기면 당연히 int형이다. `Local Variable Section`에 Integer형으로 선언한 변수는 Reference형으로 저장되어서 Stack에서 Heap으로 넘어가기때문이다. 그 과정에서 CPU가 연산을 더 한다는 비용을 초래한다.

따라서 `Local Variable Section`를 통해서 Heap을 찾아가는 경우 CPU 사용률을 높이게 된다.

### 처음에 인덱스 0번 ? reference 형의 `hidden this` 는 무엇일까 ?

그림은 reference형의 `hidden this`라고 되어있다.  이것은 예제의 testMethod()의 어디에서도 선언한 적이 없는 `Parameter Variable`이다.  이것은 Local Method 혹은 Instanc Method에 무조건 포함되는 것으로써 여기에 저장된 Reference를 통해 Heap에 있는 Class의 Instance 데이터를 찾아가게 된다.

Local Method가 아닌 Class Method, 즉 static으로 선언한 Method의 경우는 Reference 정보가 존재하지 않는다.

Class Variable과 마찬가지로 instance 에 속한 것이 아니라 Class 자체에 속해있는 것이다.

### Local Variable Section에서는 int 형? 왜 ?

`Local Variable Section`에서는 char, byte, short, boolean형으로 선언한 것들이 int 형으로 할당 되어있다.

기본형타입(primitive Type) 중 `boolean형`은 다른 기본타입과 다르다.  다른 형태의 타입들은 JVM에서 직접 지원하는 형태이다. 하지만 boolean같은 경우 다르다.

byte, short, char는 Local Variable Section이나 Operand Stack에서는 int 형으로 변환하여 저장되고 Heap 등의 다른 곳에서는 원래의 형으로 원복하여 저장한다.

JVM에서 직접 지원하지않는 `boolean`은 Stack Frame에서 int형으로 바뀌어서 저장된다. byte, short, char와는 달리 JVM내부에서 원복되는 일은 없다. 즉 Heap이나 다른 메모리영역에서도 int형을 유지한다는 것이다.  JVM에서 boolean 형은 그저 하나의 숫자에 불과하다.

### 인덱스의 숫자가 띄엄띄엄 있는 이유는?

long형과  double형에서 인덱스의 수치가 넘어갔다.  다른 기본형 타입과 다르게 long과 double형은 두 개의 엔트리를 차지한다. 이유는 대형 타입이기 때문이다.

- Local Variable Section에서는 long형과 double형을 찾아 갈 때 첫 엔트리의 인덱스를 통해 찾아며 두 개의 엔트리를 항상 연속으로 저장한다.

---

## Operand Stack

- Operand Stack : JVM이 프로그램을 수행하면서 연산을 위해 사용되는 데이터 및 그 결과를 Operand Stack에 넣고 처리한다.  Operand Stack을 간단히 말하면 JVM의 작업 공간이라고 할 수 있다.

```java
public class JvmInternal{
	public void operandStack(){
		int a, b, c;
		a = 5;
		b = 6;
		c = a + b;
	}
}
```

- 위 코드 JvmInternal 클래스를 컴파일한 후 `javap -c JvmInternal` 하면 bytecode를 볼 수 있다.

![Untitled 2](https://user-images.githubusercontent.com/56623911/196210029-3f88f02a-72fb-44ba-8d43-57cff2b81582.png)

**➡️참고**

- invokeinterface: 인터페이스 메서드 호출
- invokespecial: 생성자, private 메서드, 슈퍼 클래스의 메서드 호출
- invokestatic: static 메서드 호출
- invokevirtual: 인스턴스 메서드 호출

➡️아래는 Operand Stack Local Variable Section에서의 연산과정 그림이다.

![Untitled 3](https://user-images.githubusercontent.com/56623911/196210038-20ed707e-8477-4fa4-a989-d7cb1c733919.png)

- Operand Stack는 Array 구성되어 있다. 하지만 Local Variable Section 처럼 인덱스를 사용하여 데이터를 처리하지 않는다.

➡️위코드를 해석하면

- iconst_5는  상수 5를 push하라는 것을 의미하는 bytecode이다.
- istore_1는 Local Variable Section의 1번 인덱스에 값을 저장하는 것을 의미한다. (위에 그림참고하면 이해가 더 잘 된다. )
- bipush 6은 상수 6을 Stack에 Push하라는 의미이다. Stack Frame에서 byte, short 형 등은 내부에서 int형이 의미가 없어지는 것은 아니다. 이것은 값의 범위에 따라 내부적으로 구분되어 -128에서 -1까지와 6에서 127까지의정수는 byte로 인식한다.  -32768에서 -127까지, 128에서의 32767까지는 short로 인식한다. 6은 byte의 범위 안에 있으므로 bipush라는 Bytecode로 처리되었다.
- istore_2는 Local Variable Section의 2번 인덱스에 값을 저장하는 것을 의미한다. 그림을 보면 2번 인덱스에 상수 6이 들어가 있다.
- iload_1은 Local Variable Section의 1번 인덱스에서 int 형의 값을 로드하라는 의미이다. 1번 인덱스의 값이 Operand Stack으로 로드 되어 올라가있다.
- iload_2는 Local Variable Section의 2번 인덱스에서 int형의 값을 로드하라는 의미이다.
- iadd는 int형의 값들을 더하라는 의미이다. 연산의 대상이 되는 Operand Stack의 값들이 모두 Pop되어 연산에 사용되었다.  그리고 이 결과값이 다시 Operand Stack에 Push되었음을 그림에서 나타내고 있다.
- istrore_3은 Local Variable Section의 3번 인덱스에 값을 저장하는 것을 의미한다. Operand Stackdㅔ 잠시 저장된 연산의 결과값이 Pop되어 3번 인덱스에 저장되었다.
- return은 Method의 수행을 마치고 Stack Frame을 나가는 것을 의미한다.

---

## Frame Data

- Constant Pool Resolution 정보
- Normal Method Return
- Exception Dispatch

### Constant Pool Resolution

Resolution의미부터 알아보자.


<!-- outline-end -->
