---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
# lng_pair: id_autogeneratedsamplecontent_1
title: 프로세스와 스레드(운영체제)

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: "Dante"
# multiple category is not supported
category: auto generated
# multiple tag entries are possible`
tags: [OS, Operating System]
# thumbnail image for post
img: ":OperatingSystem2.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2022-10-12 23:55:00 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2022-10-12 23:55:00 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---
{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->

# 프로세스의 개요

## 프로그램과 프로세스의 차이

폰노이만 구조에서 프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업된다는 의미이다.

- `프로그램`은 저장장치에 저장되어 있는 정적인 상태
- 프로세스는 하나의 작업 단위이다.
- `프로세스`는 실행을 위해 메모리에 올라온 동적인 상태이다.
  - 프로세스의 작업 단위 Task

## 프로그램이 프로세스로 전환

- 프로그램을 메모리의 적당한 위치로 가져온다. 가져오는 동시에 프로세스 제어 블록이 만들어진다.

- 프로세스 제어 블록(Process Control Block)
  - 프로세스 구분자 : 메모리에는 여러 개의 프로세스가 존재하므로 각 프로세스를 구분하는 구분자(IDentification)이 필요하다.
  - 메모리 관련 정보 : CPU는 실행하려는 프로세스가 메모리의 어디에 저장되어 있는지를 알아야 작업을 할 수 있다. 이를 위해 프로세스 제어 블록에는 프로세스의 메모리 위치 정보가 담겨 있다. 또한 메모리 보호를 위한 `경계 레지스터`와 `한계 레지스터`도 포함되어 있다.
  - 각종 중간값 : 프로제스 제어 블록에는 프로세스가 사용했던 중간값이 저장된다. 시분할 시스템에서는 여러 프로세스가 번갈아가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPU를 넘겨준다.
    프로세스 A가 103번 행까지 작업한 후 다른 프로세스에 CPU를 넘겨주었다고 가정해보면, 시간이 흘러 다시 프로세스 A의 차례가 되면 104번 행부터 작업을 시작해야 한다. 이를 위해 프로세스 제어 블록에는 다음에 작업해야 할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장된다. 또한 작업의 중간값을 보관 중인 다른 레지스터도 같이 저장된다. 이렇게 저장된 값은 작업을 계속 진행할 수 있게 해준다.

결론적으로 하나의 프로세스를 실행하려면 프로세스 구분자, 메모리 관련 정보, 프로그램 카운터와 각종 레지스터 같은 중간값을 관리해야 하며, 이러한 정보를 보관하는 데이터 구조가 프로세스 제어 블록이다.

- 프로그램이 메모리에 올라와 프로세스가 되는 과정

![Untitled](https://user-images.githubusercontent.com/56623911/195375328-04fe1512-ef33-4c83-bfd0-da705a6c4a14.png)

- 프로세스와 프로그램의 관계

    ```java
    프로세스 = 프로그램 + 프로세스 제어 블록
    프로그램 = 프로세스 - 프로세스 제어 블록
    ```


---

### 일괄 작업 시스템

- Queue로 처리된다.  즉 먼저 들어온 작업부터 처리한다.

### 시분할 작업 시스템

- CPU가 1개인 컴퓨터라고 가정하면  1개로 여러개의 프로세스를 동시에 실행하는 원리. CPU가 시간을 나눠서 여러 프로세스에 적절히 배분함으로써 동시에 실행하는 것처럼 느껴진다.

### 프로세스 상태

### 프로세스 네 가지 상태(활성화 상태)

- **`생성 상태(create status)`** : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태이다. 프로세스를 관리하는 데 필요한 프로세스 제어 블록이 생성된다.
- **`준비 상태(ready status)`** : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태이다. CPU가 하나인 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 자기 실행 순서가 될 때 까지 준비 상태에서 기다려야 한다.
- `**실행 상태(running status)**` : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태로 `‘execute status’`라고 표현하기도 한다. 실행 상태에 들어간 프로세스는 일정 시간 동안 CPU를 사용할 권리를 갖는다. 만약 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면 프로세스는 준비 상태로 돌아와 다음 차례를 기다린다. 프로세스는 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 왔다 갔다 한다.
- **`완료 상태(terminate)` :** 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다. 완료 상태는 프로세스 제어 블록이 사라진 상태를 의미한다.

![Untitled 1](https://user-images.githubusercontent.com/56623911/195375264-9427cc36-fb20-4d2f-9229-1f7180ba906b.png)

- 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 `CPU 스케쥴러(CPU scheduler)`가 담당한다.
- CPU준비 상태의 프로세스 중 하나를 선택하여 실행 상태로 바꾸는 CPU 스케쥴러의 작업을 `디스패치(dispatch)`라고 한다.
- CPU 스케쥴러는 프로세스의 전 상태, 즉 생성, 준비, 실행 ,완료에 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 관리한다.
- `타임 퀀텀` 또는 `타임 슬라이스` : CPU 스케쥴러에 의해 선택된 실행 상태에서 일정 시간 동안 작업을 한다. 프로세스에 배당된 작업 시간을 타임 슬라이스 또는 타임 퀀텀이라고 한다.
- `타임 아웃(time out)` : 프로세스는 자신에게 주어진 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비생태로 돌아가는 것을 타임 아웃이라고 한다.
- 새로운 프로세스가 실행 상태로 들어오면 CPU는 일정 시간(타임 슬라이스)이 흐른 뒤 알려 달라고 클록에 요청한다.  일정 시간이 다 되면 클록은 인터럽트 사용하여 일정 시간이 흘렀다고 CPU에 알려준다.

### 프로세스의  다섯 가지 상태 (활성화 상태)

- 프로세스 네 가지 단계(생성, 준비, 실행 ,완료)만으로는 작업을 진행하는 데 문제가 없다.하지만 효율성ㅇ을 고려하여 한 가지 상태를 더 추가하였다.
  어떤 프로세스가 실행 상태에 들어가 입출력을 요구했다고 가정하면 인터럽트 시스템에서 프로세스가 입출력을 요구하면 CPU가 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다.  이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없다. 따라서 CPU도 아무 작업을 하지 않고 기다리게 되는 상황이 된다.
- `대기 상태(blocking status)` : 입출력을 요구한 프로세스가 입출력이 완료 될 때까지 기다리는 대기 상태(blocking status)라고 한다.
- `대기 상태`는 작업의 효율성을 높이기 위해 채택됨. 입출력을 요청한 프로세스를 싱행 상태에 두지 않고 대기 상태로 옮기는 것

![Untitled 2](https://user-images.githubusercontent.com/56623911/195375291-d41fed35-b5ed-4fcd-86e5-e88611668df5.png)

- 프로세스의 상태와 관련 작업
- **생성 상태(create status)**
  - `생성 상태`는 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어 블록을 할당 받을 상태이다.
  - 생성된 프로세스는 바로 실행되는 것이 아니라 준비 상태에서 자기 순서를 기다리며, PCB도 같이 준비상태로 옮겨진다.

- **준비 상태(ready status)**
  - `준비 상태`는 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태
  - 프로세스 제어 블록은 `준비 큐(ready queue)`  에서 기다리며 CPU 스케쥴러에 의해 관리된다.
  - 준비 큐는 하나가 아니고 다수이다.
  - CPU 스케쥴러는 준비 상태에서 큐를 몇 개 운영할지, 큐에 있는 어떤 프로세스의 프로세스 제어 블록을 실행 상태로 보낼지 결정한다.

- **실행 상태(running status)**
  - 실행 상태는 프로세스가 CPU를 할당 받아 실행되는 상태.
  - 준비 상태에 있는 많은 프로세스 중 실행 상태에 들어가는 프로세스는 CPU의 개수 만큼이다.
  - 실행 상태에 있는 프로세스는 주어진 시간, 타임 슬라이스 동안만 작업할 수 있다.
  - 시간을 다 사용하면 timeout(PID)가 실행된다.  그러면 실행 상태 → 준비 상태 이동된다.
  - 실행 상태 동안 작업이 완료되면 exit(PID)가 실행되어 프로세스가 정상 종료된다.
  - 실행 상태 프로세스가 입출력을 요청하면 CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)를 실행한다.
  - block(PID)는 입출력이 완료될 때까지 작업을 진행할 수 없기 때문에 해당 프로세스를 대기 상태로 옮긴다.
  - CPU 스케쥴러는 새로운 프로세스를 실행 상태로 가져온다 (dispatch)


- **대기 상태(blocking status)**
  - 대기 상태는 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태로 `‘wait status’`라고도 한다.
  - 작업의 효율을 위해 만들어진 것으로, 대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다린다.
  - 입출력이 완료되면 인터럽트가 발생하면서 대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데 이것이 wakeup(PID)이다.
  - wakeup(PID)로 해당 프로세스의 프로세스 제어 블록이 준비 상태로 이동한다.
  - 어떤 프로세스가 대기 상태에서 준비 상태로 이동하는 것은 인터럽트 때문이다. 인터럽트는 입출력으로 발생하지만 어떤 이벤트에 의해 발생하기도 한다.


- **완료 상태(terminate status)**
  - 완료 상태는 프로세스가 종료되는 상태.
  - 완료 상태에서는 코드와 사용했던 데이터를 메모리에서 삭제하고 프로세스 제어 블록을 폐기한다.
  - 정상적인 종료 → exit()
  - 오류 또는 다른 프로세스에 의해 비정상적으로 종료되는 `강제 종료(abort)`를 만나면 디버깅하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 `코어 덤프(core dump)`라고한다.
  - `코어 덤프(core dump)`는 종료 직전의 메모리 상태를 확인함으로써 오류를 수정할 수 있게 해준다.

### 휴식 상태와 보류 상태

프로세스 활성화 상태(생성, 준비, 실행, 대기, 완료)와 다른 상태가 있다. 휴식상태와 보류상태이다. 바로 알아 보자.

- **휴식 상태(pause status)**
  - 휴식 상태는 프로세스가 작업을 일시적으로 쉬고 있는 상태
  - 프로그램이 종료된 것처럼 보이지만 실행을 잠시 멈춘 것.
  - ps 명령어로 확인 가능 → `정지(stop)` 으로 되어 있다.

- **보류 상태(suspend status)**
  - 보류 상태는 `일시 정시 상태` 라고도 불린다. 프로세스가 메모리에서 잠시 쫒겨난 상태로 휴식 상태와 다르다.
  - 프로세스는 아래와 같은 경우에 보류 상태가 된다.
    - 메모리가 꽉 차서 일부 프로세스를 메모리 박으로 내보낼 때
    - 프로그램에 오류가 있어서 실행을 미루어야할 때 (임시 메모리(저장소)에 저장해 놓는다)
    - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
    - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫒아내도 큰 문제가 없을 때
    - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때

- 보류 상태 포함한 프로세스의 상태

![Untitled 3](https://user-images.githubusercontent.com/56623911/195375303-37eba852-4e38-4441-a337-a3b45da0f97e.png)

- 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 `스왑 영역(swap area)`에 보관된다.
- 스왑 영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳

> ➡️보류 상태는 스왑 영역에 있는 상태이다.

➡️휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태이다.
>

`보류 상태` 는 대기상태에서 옮겨진 `보류 대기 상태(block suspend status)`와 `준비상태에서 옮겨진 보류 준비 상태(ready suspend status)`로 구분된다.

- 각 상태에서 재시작하면 원래의 활성 상태로 들어간다.


#### 참고 문헌
- 조성호, "쉽게배우는 운영체제"

<!-- outline-end -->
